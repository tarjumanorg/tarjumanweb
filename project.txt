---

`src/pages/dashboard.astro`:
```
---
// src/pages/dashboard.astro
import Layout from "../layout/Layout.astro";
import { getAllGuestbookEntries } from "../services/guestbook.service";
import Reviews from "../components/Reviews.astro";
import type { GuestbookEntry } from "../schemas/guestbook.schema";

const { userId } = Astro.locals as { userId: string };

let reviews: GuestbookEntry[] = [];
let fetchError: string | null = null;

try {
  reviews = await getAllGuestbookEntries();

} catch (e: any) {
   fetchError = `Failed to load reviews: ${e.message}`;
   console.error("Error fetching reviews via service:", e);
}
---

<Layout title="Dashboard">
  <section>
    <p>
      Welcome! You are logged in. (User ID: {userId})
    </p>
    <p>
      This is a protected page. You can only see this if you are logged in.
    </p>
    <a href="/api/auth/signout">Sign out</a>

    {fetchError && <p style="color: red;">{fetchError}</p>}

    <Reviews reviews={reviews} />
  </section>
</Layout>
```
---

`src/pages/index.astro`:
```
---
import Layout from "../layout/Layout.astro";
const title = "Supabase and Astro Demo";
---

<Layout title={title}>
  <main>
    <h1>{title}</h1>
  </main>
</Layout>

```
---

`src/pages/order.astro`:
```
---
import Layout from "../layout/Layout.astro";
import { PACKAGE_MAP } from "../utils/constants";

const title = "Place Your Order";
const turnstileSiteKey =
  import.meta.env.PUBLIC_TURNSTILE_SITE_KEY || "1x00000000000000000000AA";

const packageMapJson = JSON.stringify(PACKAGE_MAP);
---

<Layout title={title}>
  <head>
    <script src="https://challenges.cloudflare.com/turnstile/v0/api.js" defer></script>
    <style>
      .hidden { display: none; }
      button:disabled { background-color: #ccc; cursor: not-allowed; }
 </style>
  </head>
  <main>
    <section>
      <h1>{title}</h1>
      <p>Enter your details and upload your documents to start your order.</p>

      <form
        id="order-form"
        action="/api/orders/create"
        method="post"
        enctype="multipart/form-data"
        data-package-map={packageMapJson}
      >
        <div>
          <label for="order-files">Upload Documents:</label>
          <input
            type="file"
            id="order-files"
            name="order_files"
            multiple
            required
            accept=".pdf,.doc,.docx,.txt,.jpg,.jpeg,.png,.odt,.rtf"
          />
          <small>You can select multiple files. Allowed types: PDF, DOC(X), ODT, RTF, TXT, JPG, PNG.</small>
        </div>

        <div>
          <label for="orderer-name">Your Name:</label>
          <input
            type="text"
            id="orderer-name"
            name="orderer_name"
            required
            placeholder="Enter your full name"
          />
        </div>

        <div>
          <label for="phone">Phone Number:</label>
          <input
            required
            type="tel"
            id="phone"
            name="phone"
            placeholder="+62XXXXXXX or 08XXXXXXXX"
          />
        </div>

        <div>
          <label for="package-slider">Choose Package:</label>
          <input
            type="range"
            id="package-slider"
            name="package_tier_value"
            min="1"
            max="3"
            step="1"
            value="1"
            required
          />
          <div id="package-display-container">
            Selected Package: <span id="selected-package-display">Basic</span>
          </div>
        </div>

        <div class="checkbox-group">
          <input
            type="checkbox"
            id="is-disadvantaged"
            name="is_disadvantaged"
          />
          <label for="is-disadvantaged">I am requesting consideration for Economic Disadvantage</label>
        </div>
        <div id="certificate-container" class="hidden">
          <label for="certificate-file">Upload Proof (e.g., Certificate of Indigence):</label>
          <input
            type="file"
            id="certificate-file"
            name="certificate_file"
            accept=".pdf,.jpg,.jpeg,.png"
          />
          <small>Required if economic disadvantage is checked.</small>
        </div>

        <div class="checkbox-group">
          <input type="checkbox" id="is-school" name="is_school" />
          <label for="is-school">This order is for a school or organization</label>
        </div>

        <div style="margin-top: 1.5rem;">
          <label>Verification:</label>
          <div class="cf-turnstile" data-sitekey={turnstileSiteKey}></div>
        </div>

        <div id="order-status" aria-live="polite" style="min-height: 1.5em;"></div>

        <button
          type="submit"
          id="submit-order-button"
          data-original-text="Submit Order"
        >
          Submit Order
        </button>
      </form>
    </section>
  </main>
</Layout>

<script src="../scripts/orderFormClient.ts"></script>
```
---

`src/pages/signin.astro`:
```
---
// src/pages/signin.astro
import Layout from "../layout/Layout.astro";
const title = "Sign In";
---

<Layout title={title}>
  <main>
    <section>
      <h1>{title}</h1>
      <p>
        Use Google to sign in to your account.
      </p>
      <form
        action="/api/auth/signin"
        method="post"
      >
        <button
          value="google"
          name="provider"
          type="submit"
        >
           Sign in with Google
        </button>
      </form>
    </section>
  </main>
</Layout>
```
---

`src/pages/admin/index.astro`:
```
---
// src/pages/admin/index.astro
return Astro.redirect('/admin/orders');
---
```
---

`src/pages/admin/orders/index.astro`:
```
---
import AdminLayout from "../../../layouts/AdminLayout.astro";
import { formatDate } from "../../../utils/dateUtils";
import { supabaseAdmin } from '../../../lib/supabaseAdmin';
import { OrderSchema } from '../../../schemas/order.schema';
import type { Order } from '../../../schemas/order.schema';
import { handleSupabaseError } from '../../../utils/supabaseUtils';

// Use a local type for the admin table view
interface AdminOrderTableRow {
  id: number;
  user_id: string;
  orderer_name: string;
  status: Order['status'];
  created_at: string;
  package_tier?: string | null;
}

let orders: AdminOrderTableRow[] = [];
let errorMessage: string | null = null;

try {
  // Direct DB call using supabaseAdmin
  const { data, error } = await supabaseAdmin
    .from("orders")
    .select(`id, created_at, orderer_name, status, package_tier, user_id`)
    .order("created_at", { ascending: false });
  handleSupabaseError(error, "fetch all orders (admin page)");
  const ResponseOrderSchema = OrderSchema.pick({
    id: true,
    created_at: true,
    orderer_name: true,
    status: true,
    package_tier: true,
    user_id: true,
  });
  const parseResult = ResponseOrderSchema.array().safeParse(data);
  if (!parseResult.success) {
    console.error('Admin Orders page response validation failed:', parseResult.error.flatten());
    throw new Error('Internal error: Invalid data format for orders.');
  }
  orders = parseResult.data;
} catch (e: any) {
  console.error("Error fetching admin orders:", e);
  errorMessage = "Could not load orders. Please check server logs or try again later.";
}
---

<AdminLayout title="Manage Orders">
  {errorMessage && <p style="color: red;">Error: {errorMessage}</p>}

  {orders.length === 0 && !errorMessage ? (
    <p>No orders found.</p>
  ) : (
    <table>
      <thead>
        <tr>
          <th>ID</th>
          <th>Created</th>
          <th>Orderer Name</th>
          <th>Status</th>
          <th>Package</th>
          <th>User ID</th>
          <th>Actions</th>
        </tr>
      </thead>
      <tbody>
        {orders.map((order) => (
          <tr>
            <td>{order.id}</td>
            <td>{formatDate(order.created_at)}</td>
            <td>{order.orderer_name}</td>
            <td>{order.status || 'N/A'}</td>
            <td>{order.package_tier || 'N/A'}</td>
            <td>{order.user_id}</td>
            <td>
              <a href={`/admin/orders/${order.id}`}>Details</a>
            </td>
          </tr>
        ))}
      </tbody>
    </table>
  )}
</AdminLayout>
```
---

`src/pages/admin/orders/[orderId].astro`:
```
---
import AdminLayout from "../../../layouts/AdminLayout.astro";
import { formatDate } from "../../../utils/dateUtils";
import type { ApiOrderResponse } from "../../../utils/storageUtils";
import type { SignedFileInfo } from '../../../schemas/order.schema';
import { supabaseAdmin } from '../../../lib/supabaseAdmin';
import { handleSupabaseError } from '../../../utils/supabaseUtils';
import { OrderSchema, AdminOrderDetailResponseSchema } from '../../../schemas/order.schema';
import { enrichOrderWithSignedUrls } from '../../../utils/storageUtils';

const { orderId } = Astro.params;
let order: ApiOrderResponse | null = null;
let errorMessage: string | null = null;
let orderIdNum: number | null = null;

if (!orderId || isNaN(Number(orderId))) {
    errorMessage = "Invalid Order ID provided in the URL.";
} else {
    orderIdNum = Number(orderId);
    try {
        // Direct DB call using supabaseAdmin
        const { data: orderData, error: fetchError } = await supabaseAdmin
            .from("orders")
            .select(`*`)
            .eq("id", orderIdNum)
            .single();
        handleSupabaseError(fetchError, `fetch order ${orderIdNum} (admin page)`);
        if (!orderData) {
            errorMessage = `Order with ID ${orderIdNum} not found.`;
        } else {
            const enriched = await enrichOrderWithSignedUrls(orderData);
            const parseResult = AdminOrderDetailResponseSchema.safeParse(enriched);
            if (!parseResult.success) {
                console.error('Admin Order Detail page response validation failed:', parseResult.error.flatten());
                throw new Error('Internal error: Invalid data format for order details.');
            }
            order = parseResult.data;
        }
    } catch (e: any) {
        console.error(
            `Admin Detail Page: Error fetching order ${orderIdNum}:`,
            e,
        );
        errorMessage = `An unexpected error occurred while fetching order details: ${e.message}`;
    }
}
---

<AdminLayout title={order ? `Order #${order.id} Details` : "Order Details"}>
    <a href="/admin/orders">← Back to All Orders</a>

    {errorMessage && <p class="error-message">{errorMessage}</p>}

    {
        order && orderIdNum && (
            <div class="order-details-grid">
                <section class="order-info">
                    <h2>Order Information</h2>
                    <p>
                        <strong>Order ID:</strong> {order.id}
                    </p>
                    <p>
                        <strong>Created At:</strong>{" "}
                        {formatDate(order.created_at)}
                    </p>
                    <p>
                        <strong>User ID:</strong> {order.user_id}
                    </p>
                    <p>
                        <strong>Orderer Name:</strong> {order.orderer_name}
                    </p>
                    <p>
                        <strong>Phone:</strong> {order.phone || "N/A"}
                    </p>
                    <p>
                        <strong>Package Tier:</strong>{" "}
                        {order.package_tier || "N/A"}
                    </p>
                    <p>
                        <strong>Is Disadvantaged:</strong>{" "}
                        {order.is_disadvantaged ? "Yes" : "No"}
                    </p>
                    <p>
                        <strong>Is School:</strong>{" "}
                        {order.is_school ? "Yes" : "No"}
                    </p>
                    <p>
                        <strong>Certificate:</strong>
                        {order.certificate_info?.signedUrl ? (
                            <a
                                href={order.certificate_info.signedUrl}
                                target="_blank"
                                rel="noopener noreferrer"
                            >
                                {order.certificate_info.filename ||
                                    "Certificate File"}
                            </a>
                        ) : order.certificate_info?.filename ? (
                            <span>
                                {order.certificate_info.filename} (Link Error)
                            </span>
                        ) : (
                            "N/A"
                        )}
                    </p>
                    <p>
                        <strong>Uploaded Original Files:</strong>
                    </p>
                    {order.uploaded_files_info &&
                    Array.isArray(order.uploaded_files_info) &&
                    order.uploaded_files_info.length > 0 ? (
                        <ul>
                            {order.uploaded_files_info.map((fileInfo, index) =>
                                fileInfo ? (
                                    <li>
                                        {fileInfo.signedUrl ? (
                                            <a
                                                href={fileInfo.signedUrl}
                                                target="_blank"
                                                rel="noopener noreferrer"
                                            >
                                                {fileInfo.filename ||
                                                    `File ${index + 1}`}
                                            </a>
                                        ) : (
                                            <span>
                                                {fileInfo.filename ||
                                                    `File ${index + 1}`}{" "}
                                                (Link Error)
                                            </span>
                                        )}
                                    </li>
                                ) : (
                                    <li>
                                        File {index + 1} (Error generating link)
                                    </li>
                                ),
                            )}
                        </ul>
                    ) : (
                        <p>
                            No original files uploaded or links could not be
                            generated.
                        </p>
                    )}
                    <p>
                        <strong>Current Translated File:</strong>
                        <span id="translated-file-link-container">
                            {order.translated_file_info?.signedUrl ? (
                                <a
                                    href={order.translated_file_info.signedUrl}
                                    target="_blank"
                                    rel="noopener noreferrer"
                                    data-translated-link
                                >
                                    {order.translated_file_info.filename ||
                                        "Translated File"}
                                </a>
                            ) : order.translated_file_info?.filename ? (
                                <span data-translated-link>
                                    {order.translated_file_info.filename} (Link
                                    Error)
                                </span>
                            ) : (
                                <span data-translated-link>None</span>
                            )}
                        </span>
                    </p>
                </section>

                <section class="order-update">
                    <h2>Update Order</h2>
                    <form data-update-form data-order-id={orderIdNum}>
                        <div class="form-group">
                            <label for="status">Status:</label>
                            <select id="status" name="status">
                                {OrderSchema.shape.status.options.map(option => (
                                    <option value={option} selected={order.status === option}>{option}</option>
                                ))}
                            </select>
                        </div>
                        <div class="form-group">
                            <label for="page_count">Page Count:</label>
                            <input
                                type="number"
                                id="page_count"
                                name="page_count"
                                value={order.page_count ?? ""}
                                min="0"
                                step="1"
                            />
                        </div>
                        <button type="submit">Update Order</button>
                        <div data-update-status class="status-message" />
                    </form>
                </section>

                <section class="order-upload">
                    <h2>Upload Translated File</h2>
                    <form data-upload-form data-order-id={orderIdNum}>
                        <div class="form-group">
                            <label for="translated_file">Select File:</label>
                            <input
                                type="file"
                                id="translated_file"
                                name="translated_file"
                                required
                            />
                        </div>
                        <button type="submit">Upload Translation</button>
                        <div data-upload-status class="status-message" />
                    </form>
                </section>
            </div>
        )
    }
</AdminLayout>

<script>
    import type { SignedFileInfo } from "../../../schemas/order.schema";
    import {
        setupOrderUpdateForm,
        handleTranslationUploadSubmit,
    } from "../../../scripts/adminOrderHandlers";

    function updateTranslatedFileDisplay(
        fileInfo: SignedFileInfo | undefined | null,
    ) {
        const container = document.getElementById(
            "translated-file-link-container",
        );
        if (!container) return;

        if (fileInfo?.signedUrl && fileInfo.filename) {
            container.innerHTML = `<a href="${fileInfo.signedUrl}" target="_blank" rel="noopener noreferrer" data-translated-link>${fileInfo.filename}</a>`;
        } else if (fileInfo?.filename) {
            container.innerHTML = `<span data-translated-link>${fileInfo.filename} (Link Error)</span>`;
        } else {
            container.innerHTML = `<span data-translated-link>None</span>`;
        }
    }

    const updateForm = document.querySelector(
        "[data-update-form]",
    ) as HTMLFormElement | null;
    const updateStatusEl = document.querySelector(
        "[data-update-status]",
    ) as HTMLElement | null;
    const updateSubmitButton = updateForm?.querySelector('button[type="submit"]') as HTMLButtonElement | null;
    const uploadForm = document.querySelector(
        "[data-upload-form]",
    ) as HTMLFormElement | null;
    const uploadStatusEl = document.querySelector(
        "[data-upload-status]",
    ) as HTMLElement | null;
    const fileInput = document.getElementById(
        "translated_file",
    ) as HTMLInputElement | null;

    if (updateForm && updateStatusEl && updateSubmitButton) {
        setupOrderUpdateForm(
            updateForm,
            updateStatusEl,
            updateSubmitButton,
            updateTranslatedFileDisplay
        );
    } else {
        console.warn("Update form elements (form, status div, or submit button) not found.");
    }

    if (uploadForm && uploadStatusEl && fileInput) {
        uploadForm.addEventListener("submit", (event) => {
            handleTranslationUploadSubmit(
                event,
                uploadForm,
                uploadStatusEl,
                fileInput,
                updateTranslatedFileDisplay,
            );
        });
    } else {
        console.warn(
            "Upload form elements (form, status div, or file input) not found.",
        );
    }
</script>

<style>
    button:disabled {
        background-color: #ccc;
        cursor: not-allowed;
    }

    .status-message {
        margin-top: 1rem;
        padding: 0.75rem;
        border-radius: 4px;
        display: none;
        font-weight: bold;
        text-align: center;
        border: 1px solid transparent;
    }

    .status-message.status-success {
        background-color: #d4edda;
        color: #155724;
        border-color: #c3e6cb;
        display: block;
    }

    .status-message.status-error {
        background-color: #f8d7da;
        color: #721c24;
        border-color: #f5c6cb;
        display: block;
    }

    .status-message.status-info {
        background-color: #e2e3e5;
        color: #383d41;
        border-color: #d6d8db;
        display: block;
    }
</style>

```
---

`src/pages/api/admin/orders/index.ts`:
```
import type { APIRoute } from "astro";

import { supabaseAdmin } from "../../../../lib/supabaseAdmin"; 
import { jsonResponse, jsonErrorResponse } from '../../../../utils/apiResponse';
import { handleSupabaseError } from "../../../../utils/supabaseUtils"; 
import type { Order } from '../../../../schemas/order.schema';
import { OrderSchema } from '../../../../schemas/order.schema';

// NOTE: This endpoint is currently not used by the admin frontend UI, but is kept for future enhancements (e.g., client-side filtering, live updates, or SPA admin tools).

export const GET: APIRoute = async ({ locals }) => {
    const adminUserId = locals.userId; 

    if (!adminUserId) {

         console.error("API Error (GET /api/admin/orders): Admin user ID not found in locals. Middleware might be misconfigured or bypassed.");
         return jsonErrorResponse(401, "Unauthorized: Admin session context missing.");
    }
    console.log(`API Route: GET /api/admin/orders invoked by verified admin user ${adminUserId}. Using service client for DB query.`);

    try {

        const { data, error } = await supabaseAdmin 
            .from("orders")
            .select(`
                id,
                created_at,
                orderer_name,
                status,
                package_tier,
                user_id
            `) 
            .order("created_at", { ascending: false }); 

        handleSupabaseError(error, "fetch all orders (admin service)");

        const ResponseOrderSchema = OrderSchema.pick({
          id: true,
          created_at: true,
          orderer_name: true,
          status: true,
          package_tier: true,
          user_id: true,
        });
        const parseResult = ResponseOrderSchema.array().safeParse(data);
        if (!parseResult.success) {
          console.error('Admin Orders GET response validation failed:', parseResult.error.flatten());
          return jsonErrorResponse(500, "Internal server error: Invalid data format for orders.");
        }
        return jsonResponse(200, parseResult.data || []); 

    } catch (error: any) {
        console.error(`API Error (GET /api/admin/orders with service client):`, error.message);

        return jsonErrorResponse(500, `Failed to retrieve orders: ${error.message}`);
    }
}
```
---

`src/pages/api/admin/orders/[orderId].ts`:
```
import type { APIRoute } from "astro";
import { supabaseAdmin } from "../../../../lib/supabaseAdmin";
import { jsonResponse, jsonErrorResponse } from '../../../../utils/apiResponse';
import { handleSupabaseError } from "../../../../utils/supabaseUtils";
import type { Order } from '../../../../schemas/order.schema';
import { createSignedUrlForPath, enrichOrderWithSignedUrls, type ApiOrderResponse } from "../../../../utils/storageUtils";
import { z } from "zod";
import { AdminOrderDetailResponseSchema, UpdateOrderPayloadSchema } from '../../../../schemas/order.schema';

export const GET: APIRoute = async ({ params, locals }) => {
    const adminUserId = locals.userId;
    const orderId = params.orderId;

    if (!adminUserId) {
         console.error(`API Error (GET /api/admin/orders/${orderId}): Admin user ID not found in locals.`);
         return jsonErrorResponse(401, "Unauthorized: Admin session context missing.");
    }
    console.log(`API Route: GET /api/admin/orders/${orderId} invoked by verified admin user ${adminUserId}. Using service client.`);

    const idNumResult = z.coerce.number().int().positive().safeParse(orderId);
    if (!idNumResult.success) {
        return jsonErrorResponse(400, "Invalid Order ID.");
    }
    const idNum = idNumResult.data;

    try {

        const { data: orderData, error: fetchError } = await supabaseAdmin
            .from("orders")
            .select(`*`) 
            .eq("id", idNum)
            .single(); 

        handleSupabaseError(fetchError, `fetch order ${idNum} (admin service)`);

        if (!orderData) {

            return jsonErrorResponse(404, `Order with ID ${idNum} not found.`);
        }

        console.log(`API Route: Fetched order ${idNum}. Enriching with signed URLs...`);

        const responseData: ApiOrderResponse = await enrichOrderWithSignedUrls(orderData as Order);

        const parseResult = AdminOrderDetailResponseSchema.safeParse(responseData);
        if (!parseResult.success) {
            console.error('Admin Order Detail GET response validation failed:', parseResult.error.flatten());
            return jsonErrorResponse(500, "Internal server error: Invalid data format for order details.");
        }
        return jsonResponse(200, parseResult.data);

    } catch (error: any) {
        console.error(`API Error (GET /api/admin/orders/${orderId} with service client):`, error.message);

         if (error.code === 'PGRST116' || error.message.includes('fetch order')) { 
             return jsonErrorResponse(404, `Order with ID ${idNum} not found.`);
         }
         if (error.message.startsWith("Permission Denied:")) {
             return jsonErrorResponse(403, "Forbidden: Check RLS policies for admin access.");
         }
        return jsonErrorResponse(500, `Failed to retrieve order ${idNum}: ${error.message}`);
    }
}

export const PATCH: APIRoute = async ({ request, params, locals }) => {
     const adminUserId = locals.userId;
     const orderId = params.orderId;

     if (!adminUserId) {
         console.error(`API Error (PATCH /api/admin/orders/${orderId}): Admin user ID not found in locals.`);
         return jsonErrorResponse(401, "Unauthorized: Admin session context missing.");
     }
     console.log(`API Route: PATCH /api/admin/orders/${orderId} invoked by verified admin user ${adminUserId}. Using service client.`);

    const idNumResult = z.coerce.number().int().positive().safeParse(orderId);
    if (!idNumResult.success) {
        return jsonErrorResponse(400, "Invalid Order ID.");
    }
    const idNum = idNumResult.data;

    let payload;
    try {
        payload = await request.json();
        const result = UpdateOrderPayloadSchema.safeParse(payload);
        if (!result.success) {
            return jsonErrorResponse(400, result.error.flatten());
        }
        payload = result.data;
    } catch (e) {
        return jsonErrorResponse(400, "Invalid JSON body.");
    }

    const updateData: import('../../../../schemas/order.schema').UpdateOrderPayload = { ...payload };
    const hasValidUpdate = Object.keys(updateData).length > 0;
    if (!hasValidUpdate) {
        return jsonErrorResponse(400, "No valid fields provided for update.");
    }

    let autoAdvancedStatusOverride: Order['status'] | null = null;
    // --- Auto-advance status if page_count is set for the first time ---
    if (updateData.page_count && updateData.page_count > 0) {
        const { data: currentOrderData, error: fetchCurrentError } = await supabaseAdmin
            .from("orders")
            .select("status, page_count")
            .eq("id", idNum)
            .single();
        handleSupabaseError(fetchCurrentError, `fetch current order for status auto-advance`);
        if (currentOrderData &&
            (currentOrderData.page_count === null || currentOrderData.page_count === 0) &&
            currentOrderData.status === "Pending Page Count"
        ) {
            autoAdvancedStatusOverride = "Pending Package Confirmation";
        }
    }
    // If auto-advancing, override any status sent from the form for this specific transition
    if (autoAdvancedStatusOverride) {
        updateData.status = autoAdvancedStatusOverride;
        console.log(`API Route: Auto-advancing status to "${updateData.status}" for order ${idNum} due to page count update.`);
    } else if (payload.status === null) {
        updateData.status = null;
    } else if (payload.status) {
        updateData.status = payload.status;
    }

    console.log(`API Route: Updating order ${idNum} using admin service client with data:`, updateData);

    try {
        const { data: updatedOrderData, error: updateError } = await supabaseAdmin
            .from("orders")
            .update(updateData)
            .eq("id", idNum)
            .select()
            .single();

        handleSupabaseError(updateError, `update order ${idNum} (admin service)`);

        if (!updatedOrderData) {
             console.error(`API Logic Error: Order ${idNum} not found after PATCH attempt or update failed silently.`);
             return jsonErrorResponse(404, `Order with ID ${idNum} could not be found or updated.`);
        }

        console.log(`API Route: Updated order ${idNum}. Enriching response with signed URLs...`);

        const responseData: ApiOrderResponse = await enrichOrderWithSignedUrls(updatedOrderData as Order);

        const parseResult = AdminOrderDetailResponseSchema.safeParse(responseData);
        if (!parseResult.success) {
            console.error('Admin Order Detail PATCH response validation failed:', parseResult.error.flatten());
        }

        console.log(`API Route: Updated order ${idNum} successfully. Returning enhanced data.`);
        return jsonResponse(200, responseData);

    } catch (error: any) {
        console.error(`API Error (PATCH /api/admin/orders/${orderId} with service client):`, error.message);
        if (error.code === 'PGRST116' || error.message.includes('update order')) {
             return jsonErrorResponse(404, `Order with ID ${idNum} not found when attempting update.`);
        }
         if (error.message.startsWith("Permission Denied:")) {
             return jsonErrorResponse(403, "Forbidden: Check RLS policies for admin update access.");
         }
        return jsonErrorResponse(500, `Failed to update order ${idNum}: ${error.message}`);
    }
};
```
---

`src/pages/api/admin/orders/[orderId]/upload.ts`:
```
import type { APIRoute } from "astro";
import { supabaseAdmin } from "../../../../../lib/supabaseAdmin";
import { jsonResponse, jsonErrorResponse } from '../../../../../utils/apiResponse';
import { handleSupabaseError } from "../../../../../utils/supabaseUtils";
import { sanitizeFilename, extractFilename } from "../../../../../utils/filenameUtils"; 
import { generateStoragePath, createSignedUrlForPath, enrichOrderWithSignedUrls, type ApiOrderResponse } from "../../../../../utils/storageUtils"; 
import { STORAGE_BUCKET } from "../../../../../utils/constants"; 
import type { Order } from '../../../../../schemas/order.schema';
import { z } from "zod";
import { AdminOrderDetailResponseSchema } from '../../../../../schemas/order.schema';

export const POST: APIRoute = async ({ request, params, locals }) => {
    const adminUserId = locals.userId;
    const orderId = params.orderId;

    if (!adminUserId) {
        console.error(`API Error (POST /api/admin/orders/${orderId}/upload): Admin user ID not found in locals.`);
        return jsonErrorResponse(401, "Unauthorized: Admin session context missing.");
    }
    console.log(`API Route: POST /api/admin/orders/${orderId}/upload invoked by verified admin user ${adminUserId}. Using service client.`);

    const idNumResult = z.coerce.number().int().positive().safeParse(orderId);
    if (!idNumResult.success) {
        return jsonErrorResponse(400, "Invalid Order ID.");
    }
    const idNum = idNumResult.data;

    let originalUserId: string;
    try {
        console.log(`API Route: Fetching original user ID for order ${idNum} using service client...`);
        const { data: orderData, error: fetchError } = await supabaseAdmin
            .from("orders")
            .select("user_id") 
            .eq("id", idNum)
            .maybeSingle(); 

        handleSupabaseError(fetchError, `fetch user_id for order ${idNum} (admin service upload)`);

        if (!orderData?.user_id) {

            return jsonErrorResponse(404, `Order with ID ${idNum} not found or has no associated user.`);
        }
        originalUserId = orderData.user_id;
        console.log(`API Route: Found original user ID ${originalUserId} for order ${idNum}.`);

    } catch (error: any) {
         console.error(`API Error (fetching user_id for order ${idNum} with service client):`, error.message);
         if (error.code === 'PGRST116') { 
             return jsonErrorResponse(404, `Order with ID ${idNum} not found.`);
         }
          if (error.message.startsWith("Permission Denied:")) {
             return jsonErrorResponse(403, "Forbidden: Check RLS policies for admin access.");
         }
         return jsonErrorResponse(500, `Failed to retrieve order details: ${error.message}`);
    }

    let file: File | null = null;
    let originalFilename = 'untitled_translation';
    try {
        const formData = await request.formData();
        const fileEntry = formData.get("translated_file"); 

        if (!fileEntry || typeof fileEntry === 'string' || !(fileEntry instanceof File) || fileEntry.size === 0) {
             return jsonErrorResponse(400, "Missing or invalid 'translated_file' in form data. Ensure the file input name matches and a file is selected.");
        }
        file = fileEntry;
        originalFilename = file.name;
        console.log(`API Route: Received file '${originalFilename}' for upload.`);
    } catch (error: any) {
         console.error("API Error: Failed to parse FormData.", error);
         return jsonErrorResponse(400, "Bad Request: Invalid form data.");
    }

    const filePath = generateStoragePath({
        userId: originalUserId, 
        filename: originalFilename,
        type: 'translation',
        orderId: idNum 
    });

    console.log(`API Route: Uploading translated file via service client to bucket '${STORAGE_BUCKET}' at path: ${filePath}`);
    try {
         const { error: uploadError } = await supabaseAdmin.storage
            .from(STORAGE_BUCKET)
            .upload(filePath, file!); 

        if (uploadError) {
             console.error(`API Storage Error: Failed to upload ${originalFilename} via service client. Code: ${uploadError.name}, Message: ${uploadError.message}`);

             throw new Error(`Server Error: Failed to upload file '${originalFilename}'. ${uploadError.message}`);
        }
        console.log(`API Route: Successfully uploaded ${originalFilename} via service client to ${filePath}`);

    } catch (error: any) {

         console.error(`API Error (uploading file ${filePath} via service client):`, error.message);
         return jsonErrorResponse(500, `Failed to upload file: ${error.message || 'An unexpected storage error occurred.'}`);
    }

    console.log(`API Route: Updating order ${idNum} via service client with translated_file_url: ${filePath}`);
    let updatedOrderData: Order | null = null;
    try {
        const { data, error: updateError } = await supabaseAdmin
            .from("orders")
            .update({ translated_file_url: filePath }) 
            .eq("id", idNum)
            .select() 
            .single(); 

        handleSupabaseError(updateError, `update order ${idNum} with translated file URL (admin service)`);

        if (!data) {

             console.error(`API Logic Error: Order ${idNum} not found via service client after successful update attempt.`);

             return jsonErrorResponse(500, `Order with ID ${idNum} could not be retrieved after update.`);
        }
        updatedOrderData = data;
        console.log(`API Route: Successfully updated order ${idNum} with translation URL via service client.`);

    } catch (error: any) {
         console.error(`API Error (updating order ${idNum} with URL via service client):`, error.message);

         console.warn(`Potentially orphaned file uploaded to ${filePath} due to database update failure.`);
         let statusCode = 500;
         if (error.code === 'PGRST116') statusCode = 404; 
         if (error.message.startsWith("Permission Denied:")) statusCode = 403;
         return jsonErrorResponse(statusCode, `Failed to update order with file URL: ${error.message}`);
    }

    console.log(`API Route: Enriching final response for order ${idNum} with signed URLs...`);
    const responseData: ApiOrderResponse = await enrichOrderWithSignedUrls(updatedOrderData as Order);

    const parseResult = AdminOrderDetailResponseSchema.safeParse(responseData);
    if (!parseResult.success) {
        console.error('Admin Order Upload POST response validation failed:', parseResult.error.flatten());
    }

    return jsonResponse(200, responseData);
};
```
---

`src/pages/api/auth/anonymous.ts`:
```
import type { APIRoute } from "astro";
import { supabase } from "../../../lib/supabase";
import { setAuthCookies } from '../../../utils/auth';
import { jsonResponse, jsonErrorResponse } from '../../../utils/apiResponse'; 

import { ACCESS_TOKEN, REFRESH_TOKEN } from '../../../utils/constants';

export const POST: APIRoute = async ({ cookies }) => {

  const existingAccessToken = cookies.get(ACCESS_TOKEN);
  const existingRefreshToken = cookies.get(REFRESH_TOKEN);

  if (existingAccessToken?.value && existingRefreshToken?.value) {
     console.log("Anonymous Route: Found existing tokens. Verifying session...");
     const { data: { user } } = await supabase.auth.getUser(existingAccessToken.value);
     if (user) {
        console.log(`Anonymous Route: Existing session is valid for user ${user.id}. Skipping new anonymous sign-in.`);

        return jsonResponse(200, { message: "Already authenticated anonymously", userId: user.id }); 
     } else {
        console.log("Anonymous Route: Existing session token is invalid or expired. Proceeding with sign-in.");
     }
  } else {
      console.log("Anonymous Route: No existing auth tokens found or incomplete pair.");
  }

  console.log("Anonymous Route: Attempting server-side anonymous sign-in...");
  const { data, error } = await supabase.auth.signInAnonymously();

  if (error || !data?.session || !data?.user) {
    console.error("Anonymous Route: Server-side anonymous sign-in error:", error);

    return jsonErrorResponse(500, error?.message || "Anonymous sign-in failed"); 
  }

  console.log(`Anonymous Route: Server-side anonymous sign-in successful for user ${data.user.id}. Setting cookies.`);

  setAuthCookies(cookies, data.session);

  return jsonResponse(200, { message: "Anonymous sign-in successful", userId: data.user.id }); 
};
```
---

`src/pages/api/auth/callback.ts`:
```
import type { APIRoute } from "astro";
import { supabase } from "../../../lib/supabase";
import { setAuthCookies } from '../../../utils/auth';
import { jsonErrorResponse } from '../../../utils/apiResponse'; 

export const GET: APIRoute = async ({ url, cookies, redirect }) => {
  const authCode = url.searchParams.get("code");

  if (!authCode) {

    return jsonErrorResponse(400, "No code provided"); 
  }

  const { data, error } = await supabase.auth.exchangeCodeForSession(authCode);

  if (error) {
    console.error("Auth Callback Error:", error.message);

    return jsonErrorResponse(500, error.message); 
  }

  if (!data.session) {
      console.error("Auth Callback Error: No session data returned after code exchange.");

      return jsonErrorResponse(500, "Failed to establish session."); 
  }

  // --- Anonymous to Permanent Account Linking Logic ---
  // Check if there was an active anonymous session before OAuth
  const { data: currentSessionData, error: sessionError } = await supabase.auth.getSession();
  const currentSession = currentSessionData?.session;
  const isAnonymous = currentSession?.user?.is_anonymous === true;

  let finalSession = data.session;

  if (isAnonymous) {
    try {
      // Attempt to link the OAuth identity to the anonymous user
      const { error: linkError } = await supabase.auth.linkIdentity({ provider: 'google' });
      if (linkError) {
        if (linkError.message && linkError.message.toLowerCase().includes('already registered')) {
          await supabase.auth.signOut();
          finalSession = data.session;
        } else {
          console.error('linkIdentity error:', linkError.message);
          finalSession = data.session;
        }
      } else {
        // Linking succeeded, fetch the upgraded session
        const { data: upgradedSessionData } = await supabase.auth.getSession();
        if (upgradedSessionData?.session) {
          finalSession = upgradedSessionData.session;
        }
      }
    } catch (err) {
      console.error('Exception during linkIdentity:', err);
      finalSession = data.session;
    }
  }

  setAuthCookies(cookies, finalSession);

  return redirect("/dashboard");
};
```
---

`src/pages/api/auth/signin.ts`:
```
import type { APIRoute } from "astro";
import { supabase } from "../../../lib/supabase";
import type { Provider } from "@supabase/supabase-js";
import { CALLBACK_PATH } from "../../../utils/constants";
import { jsonErrorResponse } from '../../../utils/apiResponse';

export const POST: APIRoute = async ({ request, cookies, redirect, url }) => {
  const formData = await request.formData();
  const provider = formData.get("provider")?.toString();

  const redirectUrl = `${url.origin}${CALLBACK_PATH}`;

  if (provider === "google") {
    const { data, error } = await supabase.auth.signInWithOAuth({
      provider: provider as Provider,
      options: {
        redirectTo: redirectUrl,
      },
    });

    if (error) {
      console.error("OAuth Error:", error.message);
      return jsonErrorResponse(500, error.message);
    }

    return redirect(data.url);
  }
  return jsonErrorResponse(400, "Invalid sign-in method");
};
```
---

`src/pages/api/auth/signout.ts`:
```
import type { APIRoute } from "astro";
import { deleteAuthCookies } from '../../../utils/auth';

export const GET: APIRoute = async ({ cookies, redirect }) => {

  deleteAuthCookies(cookies);

  return redirect("/signin");
};
```
---

`src/pages/api/guestbook/index.ts`:
```
// src/pages/api/guestbook/index.ts
import type { APIRoute } from "astro";
import { getAllGuestbookEntries, createGuestbookEntry } from "../../../services/guestbook.service";
import type { GuestbookEntry } from '../../../schemas/guestbook.schema';
import { jsonResponse, jsonErrorResponse } from '../../../utils/apiResponse';
import { GuestbookEntrySchema } from '../../../schemas/guestbook.schema';

export const GET: APIRoute = async () => {
  console.log("API Route: GET /api/guestbook invoked.");
  try {
    const entries = await getAllGuestbookEntries();
    // Validate response data (optional but recommended)
    const parseResult = GuestbookEntrySchema.array().safeParse(entries);
    if (!parseResult.success) {
      console.error('Guestbook GET response validation failed:', parseResult.error.flatten());
      // Optionally still return the data, or return an error if strict
      // return jsonErrorResponse(500, 'Internal server error: Invalid response data.');
    }
    return jsonResponse(200, entries);
  } catch (error: any) {
    console.error("API Error (GET /api/guestbook):", error.message);
    return jsonErrorResponse(500, "Failed to retrieve guestbook entries.");
  }
};

export const POST: APIRoute = async ({ request, locals }) => {
  console.log("API Route: POST /api/guestbook invoked.");

  const userId = locals.userId;
  if (!userId) {
      console.log("API Error: Unauthorized access attempt to POST /api/guestbook.");
      return jsonErrorResponse(401, "Unauthorized: Authentication required.");
  }
  console.log(`API Route: User authenticated. User ID: ${userId}. Ready to create guestbook entry.`);

  try {
    let validated;
    try {
      const body = await request.json();
      // Validate input using Zod
      const result = GuestbookEntrySchema.pick({ name: true, message: true }).safeParse(body);
      if (!result.success) {
        return jsonErrorResponse(400, result.error.flatten());
      }
      validated = result.data;
    } catch (e) {
      console.log("API Error: Invalid JSON body received.");
      return jsonErrorResponse(400, "Bad Request: Invalid JSON body.");
    }

    const newEntry = await createGuestbookEntry(validated);

    console.log("API Route: Guestbook entry created successfully.");
    return jsonResponse(201, newEntry);

  } catch (error: any) {
    console.error("API Error (POST /api/guestbook):", error.message);

    if (error.message.startsWith("Validation Error:")) {
         return jsonErrorResponse(400, error.message);
    }
    if (error.message.startsWith("Permission Denied:")) {
         return jsonErrorResponse(403, error.message);
    }
     if (error.message.startsWith("Database Error:")) {
         return jsonErrorResponse(500, "Failed to submit guestbook entry due to a server error.");
     }
    return jsonErrorResponse(500, "An unexpected error occurred while submitting the guestbook entry.");
  }
};
```
---

`src/pages/api/orders/create.ts`:
```
import type { APIRoute, APIContext } from "astro";
import { supabase } from "../../../lib/supabase"; 
import { createOrder } from "../../../services/order.service";
import { verifyTurnstileToken } from '../../../utils/turnstile';
import { jsonResponse, jsonErrorResponse } from '../../../utils/apiResponse';
import { sanitizeFilename } from "../../../utils/filenameUtils"; 
import { generateStoragePath } from "../../../utils/storageUtils"; 
import { PACKAGE_MAP, STORAGE_BUCKET } from "../../../utils/constants"; 

interface ValidatedFormData {
    ordererName: string;
    phone?: string;
    packageSliderValue: string; 
    isDisadvantaged: boolean;
    isSchool: boolean;
    turnstileToken: string;
    orderFiles: File[];
    certificateFile: File | null;
}

async function _parseAndValidateFormData(formData: FormData): Promise<ValidatedFormData | Response> {
    try {
        const orderer_name = formData.get("orderer_name")?.toString().trim() ?? '';
        const phone = formData.get("phone")?.toString().trim() || undefined;
        const package_tier_value = formData.get("package_tier_value")?.toString() ?? '';
        const is_disadvantaged = formData.get("is_disadvantaged") === "on";
        const is_school = formData.get("is_school") === "on";
        const turnstile_token = formData.get("cf-turnstile-response")?.toString() ?? '';
        const orderFiles = formData.getAll("order_files") as File[];
        const certificateFile = formData.get("certificate_file") as File | null;

        const { CreateOrderInputSchema } = await import("../../../schemas/order.schema");
        const result = CreateOrderInputSchema.safeParse({
            orderer_name,
            phone,
            package_tier_value,
            is_disadvantaged,
            is_school,
            turnstile_token,
        });
        if (!result.success) {
            return jsonErrorResponse(400, result.error.flatten());
        }

        const validOrderFiles = orderFiles.filter(f => f && f instanceof File && f.size > 0);
        if (validOrderFiles.length === 0) return jsonErrorResponse(400, "Bad Request: At least one main document file is required.");

        const validCertificateFile = (certificateFile && certificateFile instanceof File && certificateFile.size > 0) ? certificateFile : null;
        if (is_disadvantaged && !validCertificateFile) return jsonErrorResponse(400, "Bad Request: Certificate of indigence is required when economic disadvantage is checked.");
        if (!is_disadvantaged && validCertificateFile) console.warn("API Warning: Certificate file provided but disadvantage checkbox not checked. Ignoring certificate.");

        return {
            ordererName: orderer_name,
            phone,
            packageSliderValue: package_tier_value,
            isDisadvantaged: is_disadvantaged,
            isSchool: is_school,
            turnstileToken: turnstile_token,
            orderFiles: validOrderFiles,
            certificateFile: is_disadvantaged ? validCertificateFile : null
        };
    } catch (error: any) {
        console.error("API Error: Unexpected error during FormData parsing.", error);
        return jsonErrorResponse(500, "Server Error: Failed to process form data.");
    }
}

interface UploadResult {
    uploadedFilePaths: string[];
    certificatePath?: string;
}

async function _uploadFilesToStorage(
    userId: string,
    orderFiles: File[],
    certificateFile: File | null
): Promise<UploadResult> {
    const uploadedFilePaths: string[] = [];
    let certificatePath: string | undefined = undefined;

    console.log(`API Route: Uploading ${orderFiles.length} main document(s) for user ${userId}...`);
    try {
        const uploadPromises = orderFiles.map(async (file) => {

            const filePath = generateStoragePath({
                userId: userId,
                filename: file.name,
                type: 'original'
            });

            console.log(`API Route: Uploading ${file.name} to bucket '${STORAGE_BUCKET}' at path ${filePath}`);

            const { error: uploadError } = await supabase.storage
                .from(STORAGE_BUCKET)
                .upload(filePath, file);

            if (uploadError) {
                console.error(`API Error: Failed to upload ${file.name}. Error:`, uploadError);

                throw new Error(`Server Error: Failed to upload file '${file.name}'. ${uploadError.message}`);
            }
            console.log(`API Route: Successfully uploaded ${file.name} to ${filePath}`);
            return filePath; 
        });

        const mainFilePaths = await Promise.all(uploadPromises);
        uploadedFilePaths.push(...mainFilePaths);

        if (certificateFile) {
            console.log("API Route: Uploading certificate file...");

            const certFilePath = generateStoragePath({
                userId: userId,
                filename: certificateFile.name,
                type: 'certificate'
            });

            console.log(`API Route: Uploading ${certificateFile.name} to bucket '${STORAGE_BUCKET}' at path ${certFilePath}`);

            const { error: certUploadError } = await supabase.storage
                .from(STORAGE_BUCKET)
                .upload(certFilePath, certificateFile);

            if (certUploadError) {
                console.error(`API Error: Failed to upload certificate ${certificateFile.name}. Error:`, certUploadError);
                throw new Error(`Server Error: Failed to upload certificate file '${certificateFile.name}'. ${certUploadError.message}`);
            }
            certificatePath = certFilePath;
            console.log(`API Route: Successfully uploaded certificate ${certificateFile.name}`);
        }

        console.log("API Route: All required file uploads completed successfully.");
        return { uploadedFilePaths, certificatePath };

    } catch (error: any) {

        console.error("API Error: Error during file upload process.", error);

        if (error.message.startsWith("Server Error:")) {
            throw error; 
        } else {
            throw new Error(`Server Error: An unexpected error occurred during file processing. ${error.message}`);
        }
    }
}

export const POST: APIRoute = async ({ request, locals, clientAddress }: APIContext) => {
    console.log("API Route: POST /api/orders/create invoked.");

    const userId = locals.userId;
    if (!userId) {

        console.warn("API Warning: User ID missing in locals for protected route /api/orders/create.");
        return jsonErrorResponse(401, "Unauthorized.");
    }
    console.log(`API Route: User authenticated via middleware. User ID: ${userId}`);

    let formData: FormData;
    try {
        formData = await request.formData();
    } catch (error: any) {
        console.error("API Error: Failed to parse FormData.", error);
        return jsonErrorResponse(400, "Bad Request: Invalid form data.");
    }

    const validationResult = await _parseAndValidateFormData(formData);
    if (validationResult instanceof Response) {
        return validationResult; 
    }

    const {
        ordererName, phone, packageSliderValue, isDisadvantaged, isSchool,
        turnstileToken, orderFiles, certificateFile
    } = validationResult;

    const packageTier = PACKAGE_MAP[packageSliderValue];

    try {
        console.log("API Route: Verifying Turnstile token...");

        const forwardedIp = request.headers.get('x-nf-client-connection-ip'); 
        const cfConnectingIp = request.headers.get('cf-connecting-ip'); 
        const remoteIp = forwardedIp || cfConnectingIp || clientAddress; 
        if (!remoteIp) console.warn("API Warning: Could not determine client IP for Turnstile verification.");

        await verifyTurnstileToken(turnstileToken, remoteIp);
        console.log("API Route: Turnstile verification successful.");
    } catch (error: any) {
        console.warn("API Route: Turnstile verification failed.", error.message);

        if (error.message.startsWith("Server configuration error")) {
            return jsonErrorResponse(500, error.message); 
        }

        return jsonErrorResponse(403, `CAPTCHA verification failed: ${error.message}`);
    }

    let uploadResult: UploadResult;
    try {

        uploadResult = await _uploadFilesToStorage(userId, orderFiles, certificateFile);
    } catch (error: any) {

        return jsonErrorResponse(500, error.message);
    }

    try {
        console.log(`API Route: Calling createOrder service for user ${userId}...`);

        const orderInput = {
            user_id: userId,
            orderer_name: ordererName,
            phone,
            package_tier: packageTier,
            is_disadvantaged: isDisadvantaged,
            is_school: isSchool,
            uploaded_file_urls: uploadResult.uploadedFilePaths,
            certificate_url: uploadResult.certificatePath,
            page_count: undefined,
            total_price: undefined
        };
        const newOrder = await createOrder(orderInput);

        console.log("API Route: Order created successfully in database:", newOrder.id);
        return jsonResponse(201, newOrder); 

    } catch (error: any) {

        console.error("API Error (POST /api/orders/create - Service Call):", error.message);

        if (error.message.startsWith("Validation Error:")) {

            console.error("Service Validation Error:", error.message);
            return jsonErrorResponse(400, `Bad Request: ${error.message}`); 
        }
        if (error.message.startsWith("Database Error:") || error.message.startsWith("Permission Denied:")) {

            console.error("Database or Permission Error during order creation:", error.message);

             return jsonErrorResponse(500, `Failed to save order details after uploading files. Please contact support. ${error.message}`);
        }

        return jsonErrorResponse(500, `An unexpected server error occurred while saving the order: ${error.message}`);
    }
};
```
---

`src/pages/api/orders/index.ts`:
```
import type { APIRoute } from "astro";
import { supabase } from "../../../lib/supabase";
import { OrderSchema } from "../../../schemas/order.schema";
import { jsonResponse, jsonErrorResponse } from '../../../utils/apiResponse';

export const GET: APIRoute = async ({ locals }) => {
  const userId = locals.userId;
  if (!userId) {
    return jsonErrorResponse(401, "Unauthorized: User not logged in.");
  }

  try {
    const { data, error } = await supabase
      .from("orders")
      .select("id, orderer_name, status, created_at, page_count, package_tier, total_price, estimated_delivery_date")
      .eq("user_id", userId)
      .order("created_at", { ascending: false });

    if (error) {
      return jsonErrorResponse(500, error.message);
    }

    // Validate response data (optional but recommended)
    const parseResult = OrderSchema.pick({
      id: true,
      orderer_name: true,
      status: true,
      created_at: true,
      page_count: true,
      package_tier: true,
      total_price: true,
      estimated_delivery_date: true,
    }).array().safeParse(data);
    if (!parseResult.success) {
      return jsonErrorResponse(500, 'Internal server error: Invalid data format for orders.');
    }

    return jsonResponse(200, parseResult.data);
  } catch (e: any) {
    return jsonErrorResponse(500, e.message || 'Unknown error');
  }
};

```
---

`src/pages/api/orders/[orderId].ts`:
```
import type { APIRoute } from "astro";
import { supabase } from "../../../lib/supabase";
import { OrderSchema, UserOrderDetailSchema } from "../../../schemas/order.schema";
import { jsonResponse, jsonErrorResponse } from '../../../utils/apiResponse';
import { z } from "zod";
import { PACKAGES_DETAILS_MAP } from '../../../utils/constants';
import { enrichUserOrderWithSignedUrls } from '../../../utils/supabaseUtils';

// GET /api/orders/[orderId]
export const GET: APIRoute = async ({ params, locals }) => {
  const userId = locals.userId;
  const orderId = params.orderId;
  if (!userId) return jsonErrorResponse(401, "Unauthorized: User not logged in.");
  const idNumResult = z.coerce.number().int().positive().safeParse(orderId);
  if (!idNumResult.success) return jsonErrorResponse(400, "Invalid Order ID.");
  const idNum = idNumResult.data;

  const { data, error } = await supabase
    .from("orders")
    .select("*")
    .eq("id", idNum)
    .eq("user_id", userId)
    .maybeSingle();
  if (error) return jsonErrorResponse(500, error.message);
  if (!data) return jsonErrorResponse(404, "Order not found.");
  
  // Parse and validate base order data
  const parseResult = OrderSchema.safeParse(data);
  if (!parseResult.success) return jsonErrorResponse(500, 'Internal server error: Invalid order data.');
  
  // Enrich order with signed URLs
  const enrichedOrder = await enrichUserOrderWithSignedUrls(parseResult.data);
  
  // Validate enriched order structure
  const enrichedResult = UserOrderDetailSchema.safeParse(enrichedOrder);
  if (!enrichedResult.success) return jsonErrorResponse(500, 'Internal server error: Invalid enriched order data.');
  
  return jsonResponse(200, enrichedResult.data);
};

// PATCH /api/orders/[orderId]
export const PATCH: APIRoute = async ({ request, params, locals }) => {
  const userId = locals.userId;
  const orderId = params.orderId;
  if (!userId) return jsonErrorResponse(401, "Unauthorized: User not logged in.");
  const idNumResult = z.coerce.number().int().positive().safeParse(orderId);
  if (!idNumResult.success) return jsonErrorResponse(400, "Invalid Order ID.");
  const idNum = idNumResult.data;

  let body;
  try {
    body = await request.json();
  } catch {
    return jsonErrorResponse(400, "Invalid JSON body.");
  }
  const bodySchema = z.object({ packageIdentifier: z.string() });
  const bodyResult = bodySchema.safeParse(body);
  if (!bodyResult.success) return jsonErrorResponse(400, bodyResult.error.flatten());
  const { packageIdentifier } = bodyResult.data;

  // Fetch current order
  const { data: order, error } = await supabase
    .from("orders")
    .select("*")
    .eq("id", idNum)
    .eq("user_id", userId)
    .maybeSingle();
  if (error) return jsonErrorResponse(500, error.message);
  if (!order) return jsonErrorResponse(404, "Order not found.");
  if (!order.page_count || order.page_count <= 0) return jsonErrorResponse(409, "Page count not yet confirmed by admin.");
  if (order.status !== "Pending Package Confirmation") return jsonErrorResponse(409, "Order is not awaiting package confirmation.");

  const pkg = PACKAGES_DETAILS_MAP[packageIdentifier];
  if (!pkg) return jsonErrorResponse(400, "Invalid package selected.");
  const newTotalPrice = order.page_count * pkg.pricePerPage;
  const now = new Date();
  const estimatedDelivery = new Date(now.getTime() + pkg.turnaroundDays * 24 * 60 * 60 * 1000);

  const updatePayload = {
    package_tier: pkg.name,
    total_price: newTotalPrice,
    estimated_delivery_date: estimatedDelivery.toISOString(),
    status: "Pending Payment"
  };
  const { data: updated, error: updateError } = await supabase
    .from("orders")
    .update(updatePayload)
    .eq("id", idNum)
    .eq("user_id", userId)
    .select()
    .maybeSingle();
  if (updateError) return jsonErrorResponse(500, updateError.message);
  if (!updated) return jsonErrorResponse(500, "Order update failed.");
  
  // Validate the updated order data
  const parseResult = OrderSchema.safeParse(updated);
  if (!parseResult.success) {
      console.error('PATCH response validation failed:', parseResult.error.flatten());
      return jsonErrorResponse(500, 'Internal server error: Invalid data format');
  }
  
  return jsonResponse(200, parseResult.data);
};

```
---

`src/pages/dashboard/my-orders.astro`:
```
---
import Layout from "../../layout/Layout.astro";
const title = "My Orders";
---

<Layout title={title}>
  <main>
    <h1>{title}</h1>
    <section>
      <div id="orders-list-loading">Loading your orders...</div>
      <table id="orders-table" style="display:none;">
        <thead>
          <tr>
            <th>ID</th>
            <th>Orderer Name</th>
            <th>Status</th>
            <th>Created</th>
            <th>Page Count</th>
            <th>Package</th>
            <th>Total Price</th>
            <th>Estimated Delivery</th>
            <th>Details</th>
          </tr>
        </thead>
        <tbody id="orders-table-body"></tbody>
      </table>
      <div id="orders-list-error" style="color:red;"></div>
    </section>
  </main>
  <script type="module">
    async function fetchOrders() {
      const loading = document.getElementById('orders-list-loading');
      const table = document.getElementById('orders-table');
      const tbody = document.getElementById('orders-table-body');
      const errorDiv = document.getElementById('orders-list-error');
      loading.style.display = '';
      table.style.display = 'none';
      errorDiv.textContent = '';
      try {
        const res = await fetch('/api/orders');
        if (!res.ok) throw new Error(await res.text());
        const orders = await res.json();
        if (!Array.isArray(orders) || orders.length === 0) {
          loading.textContent = 'No orders found.';
          return;
        }
        loading.style.display = 'none';
        table.style.display = '';
        tbody.innerHTML = '';
        for (const order of orders) {
          const tr = document.createElement('tr');
          tr.innerHTML = `
            <td>${order.id}</td>
            <td>${order.orderer_name}</td>
            <td>${order.status}</td>
            <td>${new Date(order.created_at).toLocaleString()}</td>
            <td>${order.page_count ?? ''}</td>
            <td>${order.package_tier ?? ''}</td>
            <td>${order.total_price ? (order.total_price).toLocaleString('id-ID', { style: 'currency', currency: 'IDR' }) : ''}</td>
            <td>${order.estimated_delivery_date ? new Date(order.estimated_delivery_date).toLocaleDateString() : ''}</td>
            <td><a href="/dashboard/my-orders/${order.id}">Details</a></td>
          `;
          tbody.appendChild(tr);
        }
      } catch (e) {
        loading.style.display = 'none';
        errorDiv.textContent = e.message || 'Failed to load orders.';
      }
    }
    fetchOrders();
  </script>
</Layout>

```
---

`src/pages/dashboard/my-orders/[orderId].astro`:
```
---
import Layout from "../../../layout/Layout.astro";
import { PACKAGES_DETAILS } from '../../../utils/constants';
const title = "Order Details";
const packages = PACKAGES_DETAILS;
---
<Layout title={title}>
  <main id="order-detail-main-content" data-packages={JSON.stringify(packages)}>
    <h1>{title}</h1>
    <section id="order-detail-section">
      <div id="order-detail-loading">Loading order details...</div>
      <div id="order-detail-error" style="color:red;"></div>
      <div id="order-detail-content" style="display:none;"></div>
    </section>
  </main>
  <script type="module">
    // Get the element holding the data
    const mainContentElement = document.getElementById('order-detail-main-content');
    // Parse the data attribute
    const packages = JSON.parse(mainContentElement.dataset.packages || '[]');
    const orderId = window.location.pathname.split('/').pop();
    async function fetchOrder() {
      const loading = document.getElementById('order-detail-loading');
      const errorDiv = document.getElementById('order-detail-error');
      const contentDiv = document.getElementById('order-detail-content');
      loading.style.display = '';
      contentDiv.style.display = 'none';
      errorDiv.textContent = '';
      try {
        const res = await fetch(`/api/orders/${orderId}`);
        if (!res.ok) throw new Error(await res.text());
        const order = await res.json();
        loading.style.display = 'none';
        contentDiv.style.display = '';
        renderOrder(order);
      } catch (e) {
        loading.style.display = 'none';
        errorDiv.textContent = e.message || 'Failed to load order.';
      }
    }
    function renderOrder(order) {
      const contentDiv = document.getElementById('order-detail-content');
      let html = `<p><strong>Order ID:</strong> ${order.id}</p>
        <p><strong>Orderer Name:</strong> ${order.orderer_name}</p>
        <p><strong>Status:</strong> ${order.status}</p>
        <p><strong>Created At:</strong> ${new Date(order.created_at).toLocaleString()}</p>
        <p><strong>Page Count:</strong> ${order.page_count ?? 'N/A'}</p>`;
      if (order.status === 'Pending Page Count' || !order.page_count) {
        html += `<p>Admin is reviewing your documents to confirm the page count. Package selection will be available soon.</p>`;
      } else if (order.status === 'Pending Package Confirmation' && order.page_count > 0) {
        html += `<p><strong>Page Count:</strong> ${order.page_count}</p>`;
        html += `<form id="package-select-form">
          <fieldset>
            <legend>Select a Package</legend>`;
        for (const pkg of packages) {
          html += `<label style="display:block;margin-bottom:0.5em;">
            <input type="radio" name="package" value="${pkg.id}" ${order.package_tier === pkg.name ? 'checked' : ''} />
            <strong>${pkg.name}</strong> - IDR ${(pkg.pricePerPage).toLocaleString('id-ID')} per page, ${pkg.turnaroundDays} day(s)
            <br/><small>${pkg.description || ''}</small>
          </label>`;
        }
        html += `</fieldset>
          <div id="package-summary"></div>
          <button type="submit" id="confirm-package-btn">Confirm Package and Proceed to Payment</button>
        </form>`;
      } else {
        html += `<p><strong>Package:</strong> ${order.package_tier ?? ''}</p>
          <p><strong>Total Price:</strong> ${order.total_price ? (order.total_price).toLocaleString('id-ID', { style: 'currency', currency: 'IDR' }) : ''}</p>
          <p><strong>Estimated Delivery:</strong> ${order.estimated_delivery_date ? new Date(order.estimated_delivery_date).toLocaleDateString() : ''}</p>`;
      }
      contentDiv.innerHTML = html;
      if (order.status === 'Pending Package Confirmation' && order.page_count > 0) setupPackageForm(order);
    }
    function setupPackageForm(order) {
      const form = document.getElementById('package-select-form');
      const summaryDiv = document.getElementById('package-summary');
      let selectedId = null;
      form.addEventListener('change', (e) => {
        if (e.target.name === 'package') {
          selectedId = e.target.value;
          updateSummary();
        }
      });
      form.addEventListener('submit', async (e) => {
        e.preventDefault();
        if (!selectedId) {
          summaryDiv.textContent = 'Please select a package.';
          return;
        }
        document.getElementById('confirm-package-btn').disabled = true;
        summaryDiv.textContent = 'Submitting...';
        try {
          const res = await fetch(`/api/orders/${order.id}`, {
            method: 'PATCH',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ packageIdentifier: selectedId })
          });
          if (!res.ok) throw new Error(await res.text());
          summaryDiv.textContent = 'Package confirmed! Please proceed to payment.';
          fetchOrder();
        } catch (err) {
          summaryDiv.textContent = err.message || 'Failed to confirm package.';
        } finally {
          document.getElementById('confirm-package-btn').disabled = false;
        }
      });
      function updateSummary() {
        const pkg = packages.find(p => p.id === selectedId);
        if (!pkg) { summaryDiv.textContent = ''; return; }
        const total = order.page_count * pkg.pricePerPage;
        const delivery = new Date(Date.now() + pkg.turnaroundDays * 24 * 60 * 60 * 1000);
        summaryDiv.innerHTML = `<strong>Selected Package:</strong> ${pkg.name}<br/>
          <strong>Total Price:</strong> IDR ${total.toLocaleString('id-ID')}<br/>
          <strong>Estimated Delivery:</strong> ${delivery.toLocaleDateString()}`;
      }
    }
    fetchOrder();
  </script>
</Layout>

```
---
