---

`astro.config.mjs`:
```
import { defineConfig } from 'astro/config';
import netlify from '@astrojs/netlify';

export default defineConfig({
  site: 'https://tarjuman.netlify.app',
  output: 'server',
  adapter: netlify(),

});
```
---

`tsconfig.json`:
```
{
  "extends": "astro/tsconfigs/strict",
  "include": [".astro/types.d.ts", "**/*"],
  "exclude": ["dist"]
}

```
---

`src/env.d.ts`:
```
// src/env.d.ts
declare namespace App {
  interface Locals {
    // Changed from email: string to userId?: string
    // Optional because not all requests will have an authenticated user
    userId?: string;
  }
}
```
---

`src/components/Reviews.astro`:
```
---
// src/components/Reviews.astro
import type { GuestbookEntry } from "../types/types";
interface Props {
  reviews: GuestbookEntry[];
}
const { reviews } = Astro.props;
---

<div>
  <form id="guestbook-form" method="post" action="/api/guestbook">
    <h3>Leave a message</h3>
    {/* Added min-height and margin for better layout */}
    <div
      id="form-status"
      aria-live="polite"
      style="min-height: 1.5em; margin-bottom: 1em; font-weight: bold;"
    >
    </div>

    <div>
      <label for="name">Name</label>
      <input
        id="name"
        type="text"
        placeholder="Your Name"
        required
        name="name"
      />
    </div>
    <div>
      <label for="message">Message</label>
      <input
        id="message"
        type="text"
        placeholder="A friendly message..."
        required
        name="message"
      />
    </div>
    {/* Added data-original-text attribute for handler */}
    <button id="submit-button" type="submit" data-original-text="Submit">
      Submit
    </button>
  </form>

  <h3>Guestbook Entries</h3>
  <div id="reviews-list">
    {
      reviews.length > 0 ? (
        <ul>
          {reviews.map((review) => (
            <li>
              <p>
                <strong>{review.name}</strong>
              </p>{" "}
              {/* Made name bold */}
              <p>{review.message}</p>
            </li>
          ))}
        </ul>
      ) : (
        <p>No reviews yet. Be the first!</p>
      )
    }
  </div>
</div>

<script>
  import { setupFormSubmitListener } from "../scripts/formHandler";
  import type { FormSubmitOptions } from "../types/types";

  const form = document.getElementById(
    "guestbook-form",
  ) as HTMLFormElement | null;
  const nameInput = document.getElementById("name") as HTMLInputElement | null;
  const messageInput = document.getElementById(
    "message",
  ) as HTMLInputElement | null;
  const statusDiv = document.getElementById(
    "form-status",
  ) as HTMLElement | null;
  const submitButton = document.getElementById(
    "submit-button",
  ) as HTMLButtonElement | null;

  if (form && nameInput && messageInput && statusDiv && submitButton) {
    const preparePayloadForReview = (): Record<string, any> | null => {
      const name = nameInput.value.trim();
      const message = messageInput.value.trim();

      if (!name || !message) {
        if (statusDiv) {
          statusDiv.textContent = "Please enter both name and message.";
          statusDiv.style.color = "red";
        }
        return null;
      }
      return { name, message };
    };

    const onReviewSuccess = (data: any, formElement: HTMLFormElement) => {
      if (statusDiv) {
        statusDiv.textContent = "Message submitted successfully!";
        statusDiv.style.color = "green";
      }
      formElement.reset();
      // IMPORTANT: This simple example doesn't dynamically update the list above.
      // A page refresh would be needed to see the new entry, or use
      // more advanced techniques (HTMX, Alpine, framework component).
      console.log("Submitted data:", data);
      // Optional: Clear success message after a delay
      setTimeout(() => {
        if (statusDiv) statusDiv.textContent = "";
      }, 5000);
    };

    const onReviewError = (error: Error, statusElement: HTMLElement | null) => {
      if (statusElement) {
        statusElement.textContent = `Error: ${error.message || "Could not submit message."}`;
        statusElement.style.color = "red";
      }
      // Optional: Clear error message after a delay
      // setTimeout(() => { if(statusDiv) statusDiv.textContent = ''; }, 8000);
    };

    // Define options for the handler
    const options: FormSubmitOptions = {
      formElement: form,
      statusElement: statusDiv,
      submitButton: submitButton,
      preparePayload: preparePayloadForReview,
      onSuccess: onReviewSuccess,
      onError: onReviewError,
      // endpoint and method will be taken from the form's action and method attributes
      submitText: "Submit", // Explicitly set restore text if needed
    };

    // Use the setup function for simple forms
    setupFormSubmitListener(options);
  } else {
    console.error(
      "Could not find all required form elements for guestbook submission script.",
    );
  }
</script>

```
---

`src/layout/Layout.astro`:
```
---
interface Props {
  title: string;
}

const description = "Astro and Supabase demo app";
const { title } = Astro.props;
const ogImageURL = new URL("hero.png", Astro.site).href;
const canonicalURL = new URL(Astro.url).href;
---

<html lang="en">
  <head>
    <title>{title}</title>
    <meta charset="utf-8" />
    <link rel="icon" type="image/svg+xml" href="/favicon.svg" />
    <meta name="viewport" content="width=device-width" />
    <meta name="generator" content={Astro.generator} />
    <meta name="description" content={description} />
    <meta property="twitter:image" content={ogImageURL} />
    <meta property="twitter:card" content="summary_large_image" />
    <meta property="twitter:title" content={title} />
    <meta property="twitter:description" content={description} />
    <meta property="og:image" content={ogImageURL} />
    <meta property="og:title" content={title} />
    <meta property="og:description" content={description} />
    <meta property="og:url" content={canonicalURL} />
  </head>
  <body>
    <nav>
      <div>
        <a href="/">Astro</a>
        <div>
          <ul>
            <li>
              <a href="/dashboard">Dashboard</a>
            </li>
            <li>
              <a href="/signin">Sign in</a>
            </li>
          </ul>
        </div>
      </div>
    </nav>
    <slot />
  </body>
</html>
```
---

`src/lib/supabase.ts`:
```
// src/lib/supabase.ts
import { createClient } from "@supabase/supabase-js";

const supabaseUrl = import.meta.env.PUBLIC_SUPABASE_URL;
const supabaseAnonKey = import.meta.env.PUBLIC_SUPABASE_ANON_KEY;

if (!supabaseUrl || !supabaseAnonKey) {
  throw new Error("Supabase URL or Anon Key is missing.");
}

export const supabase = createClient(
  supabaseUrl,
  supabaseAnonKey,
  {
    auth: {
      flowType: "pkce",
      autoRefreshToken: true,
      detectSessionInUrl: false,
      persistSession: true,
    },
  },
);
```
---

`src/middleware/index.ts`:
```
// src/middleware/index.ts
import { defineMiddleware } from "astro:middleware";
import { supabase } from "../lib/supabase";
import { setAuthCookies, deleteAuthCookies } from '../utils/auth';
import { ACCESS_TOKEN_COOKIE, REFRESH_TOKEN_COOKIE } from '../utils/constants';

// Consider moving these to constants.ts as well if used elsewhere
// Or import if they are defined there
const protectedPaths = ["/dashboard"];
const redirectPaths = ["/signin"]; // e.g., signin, register
const protectedAPIPaths = ["/api/guestbook", "/api/orders/create"];

function matchesPath(pathname: string, pathsToCheck: string[]): boolean {
  const normalizedPathname = pathname.endsWith('/') && pathname.length > 1
    ? pathname.slice(0, -1)
    : pathname;
  return pathsToCheck.includes(normalizedPathname);
}

export const onRequest = defineMiddleware(
  async ({ locals, url, cookies, redirect }, next) => {
    // --- 1. Centralized Auth Check ---
    const accessToken = cookies.get(ACCESS_TOKEN_COOKIE);
    const refreshToken = cookies.get(REFRESH_TOKEN_COOKIE);
    locals.userId = undefined; // Ensure locals.userId is reset per request

    if (accessToken) {
      console.log("Middleware: Access token found. Verifying...");
      const { data: { user }, error: getUserError } = await supabase.auth.getUser(accessToken.value);

      if (user) {
        console.log(`Middleware: User ${user.id} verified successfully via access token.`);
        locals.userId = user.id;
        // Optional: Refresh session proactively if needed, but getUser is usually sufficient
      } else {
        console.log("Middleware: Access token invalid or expired.", getUserError?.message);
        if (refreshToken) {
          console.log("Middleware: Refresh token found. Attempting session refresh...");
          // Use setSession as it handles refresh internally when access token is provided (even if expired)
          const { data: refreshData, error: refreshError } = await supabase.auth.setSession({
            access_token: accessToken.value,
            refresh_token: refreshToken.value,
          });

          if (refreshData?.session && refreshData?.user) {
            console.log(`Middleware: Session refreshed successfully for user ${refreshData.user.id}. Setting cookies.`);
            locals.userId = refreshData.user.id;
            setAuthCookies(cookies, refreshData.session); // Update cookies with new tokens/expiry
          } else {
            console.log("Middleware: Session refresh failed. Deleting auth cookies.", refreshError?.message);
            deleteAuthCookies(cookies);
            // locals.userId remains undefined
          }
        } else {
          console.log("Middleware: Invalid access token and no refresh token found. Deleting auth cookies.");
          deleteAuthCookies(cookies);
          // locals.userId remains undefined
        }
      }
    } else {
       console.log("Middleware: No access token found.");
       // If only refresh token exists, Supabase client handles refresh on next DB call attempt,
       // but we can't pre-validate user easily here without access token for getUser.
       // If access token is missing, treat as unauthenticated for initial checks.
       // If refresh token exists alone, delete it as it's likely stale without access token.
       if (refreshToken) {
           console.log("Middleware: Access token missing but refresh token exists. Deleting stale refresh token.");
           deleteAuthCookies(cookies); // deleteAuthCookies targets both
       }
    }

    // --- 2. Path-Based Logic (using locals.userId) ---
    const isProtectedRoute = matchesPath(url.pathname, protectedPaths);
    const isProtectedAPIRoute = matchesPath(url.pathname, protectedAPIPaths);
    const isRedirectRoute = matchesPath(url.pathname, redirectPaths);

    if (isProtectedRoute && !locals.userId) {
      console.log(`Middleware: Blocked access to protected route ${url.pathname}. Redirecting to signin.`);
      return redirect("/signin");
    }

    if (isProtectedAPIRoute && !locals.userId) {
       console.log(`Middleware: Blocked access to protected API route ${url.pathname}. Returning 401.`);
       return new Response(JSON.stringify({ error: "Unauthorized" }), { status: 401 });
    }

    if (isRedirectRoute && locals.userId) {
        console.log(`Middleware: User already logged in (User ID: ${locals.userId}). Redirecting from ${url.pathname} to dashboard.`);
        return redirect("/dashboard");
    }

    // --- 3. Proceed if no action taken ---
    console.log(`Middleware: Allowing request to ${url.pathname}. Authenticated User ID: ${locals.userId ?? 'None'}`);
    return next();
  },
);
```
---

`src/pages/dashboard.astro`:
```
---
// src/pages/dashboard.astro
import Layout from "../layout/Layout.astro";
import { getAllGuestbookEntries } from "../services/guestbook.service";
import Reviews from "../components/Reviews.astro";
import type { GuestbookEntry } from "../types/types";

const { userId } = Astro.locals as { userId: string };

let reviews: GuestbookEntry[] = [];
let fetchError: string | null = null;

try {
  reviews = await getAllGuestbookEntries();

} catch (e: any) {
   fetchError = `Failed to load reviews: ${e.message}`;
   console.error("Error fetching reviews via service:", e);
}
---

<Layout title="Dashboard">
  <section>
    <p>
      Welcome! You are logged in. (User ID: {userId})
    </p>
    <p>
      This is a protected page. You can only see this if you are logged in.
    </p>
    <a href="/api/auth/signout">Sign out</a>

    {fetchError && <p style="color: red;">{fetchError}</p>}

    <Reviews reviews={reviews} />
  </section>
</Layout>
```
---

`src/pages/index.astro`:
```
---
import Layout from "../layout/Layout.astro";
const title = "Supabase and Astro Demo";
---

<Layout title={title}>
  <main>
    <h1>{title}</h1>
    <ul>
      <li
      >
      </li>
       &plus;
      <li
      >
      </li>
    </ul>
    <p>This page was pre-rendered at build time</p>
  </main>
</Layout>

```
---

`src/pages/order.astro`:
```
---
// src/pages/order.astro
import Layout from "../layout/Layout.astro";

const title = "Place Your Order";
const turnstileSiteKey = "0x4AAAAAABDz77Fkj-zw6ls4";
---

<Layout title={title}>
  <head>
    <script src="https://challenges.cloudflare.com/turnstile/v0/api.js" defer
    ></script>
  </head>
  <main>
    <section>
      <h1>{title}</h1>
      <p>Enter your details to start your order.</p>

      <form id="order-form" action="/api/orders/create" method="post">
        <div>
          <label for="orderer-name">Your Name:</label>
          <input
            type="text"
            id="orderer-name"
            name="orderer_name"
            required
            placeholder="Enter your name"
          />
        </div>

        <div style="margin-top: 1rem;">
          <label for="phone">Phone Number:</label>
          <input
            required
            type="tel"
            id="phone"
            name="phone"
            placeholder="+62XXXXXXX"
          />
        </div>

        <!-- Turnstile Widget -->
        <div
          class="cf-turnstile"
          data-sitekey={turnstileSiteKey}
          style="margin-top: 1rem;"
        >
        </div>
        <!-- End Turnstile Widget -->

        <div
          id="order-status"
          aria-live="polite"
          style="margin-top: 1rem; min-height: 1.5em; font-weight: bold;"
        >
        </div>

        <button
          type="submit"
          id="submit-order-button"
          style="margin-top: 1rem;"
          data-original-text="Submit Order"
        >
          Submit Order
        </button>
      </form>
    </section>
  </main>
</Layout>

<script>
  import { submitFormData, resetTurnstileWidget } from "../scripts/formHandler";
  import type { FormSubmitOptions } from "../types/types";

  const form = document.getElementById("order-form") as HTMLFormElement | null;
  const nameInput = document.getElementById(
    "orderer-name",
  ) as HTMLInputElement | null;
  const phoneInput = document.getElementById(
    "phone",
  ) as HTMLInputElement | null;
  const submitButton = document.getElementById(
    "submit-order-button",
  ) as HTMLButtonElement | null;
  const statusDiv = document.getElementById(
    "order-status",
  ) as HTMLElement | null;
  const turnstileResponseInputName = "cf-turnstile-response";

  if (form && nameInput && phoneInput && submitButton && statusDiv) {
    form.addEventListener("submit", async (event) => {
      event.preventDefault();

      if (statusDiv) statusDiv.textContent = "Ensuring session...";
      if (submitButton) {
        submitButton.disabled = true;
        submitButton.textContent = "Initializing...";
      }

      try {
        const authResponse = await fetch("/api/auth/anonymous", {
          method: "POST",
        });
        if (!authResponse.ok) {
          let errorMsg = "Authentication setup failed.";
          try {
            const errorData = await authResponse.json();
            errorMsg =
              errorData.error ||
              `Authentication setup failed: Status ${authResponse.status}`;
          } catch (e) {
            /* Ignore */
          }
          throw new Error(errorMsg);
        }
        console.log("Session ensured via server endpoint.");

        const preparePayloadForOrder = (): Record<string, any> | null => {
          const ordererName = nameInput.value.trim();
          const phone = phoneInput.value.trim();
          const formData = new FormData(form);
          const turnstileToken = formData
            .get(turnstileResponseInputName)
            ?.toString();

          if (!ordererName) {
            if (statusDiv) {
              statusDiv.textContent = "Please enter your name.";
              statusDiv.style.color = "red";
            }
            nameInput.focus();
            return null;
          }

          if (!phone) {
            if (statusDiv) {
              statusDiv.textContent = "Please enter your phone number.";
              statusDiv.style.color = "red";
            }
            phoneInput.focus();
            return null;
          }

          if (!turnstileToken) {
            if (statusDiv) {
              statusDiv.textContent =
                "CAPTCHA challenge failed, missing, or expired. Please try again.";
              statusDiv.style.color = "red";
            }
            resetTurnstileWidget(form);
            return null;
          }

          const payload: Record<string, any> = {
            orderer_name: ordererName,
            turnstileToken: turnstileToken,
            phone: phone,
          };

          return payload;
        };

        const onOrderSuccess = (data: any, formElement: HTMLFormElement) => {
          if (statusDiv) {
            statusDiv.textContent = `Order submitted successfully! Order ID: ${data.id}`;
            statusDiv.style.color = "green";
          }
          formElement.reset();
          resetTurnstileWidget(formElement);
          setTimeout(() => {
            if (statusDiv) statusDiv.textContent = "";
          }, 5000);
        };

        const onOrderError = (
          error: Error,
          statusElement: HTMLElement | null,
        ) => {
          if (statusElement) {
            if (error.message.includes("CAPTCHA verification failed")) {
              statusElement.textContent = `Error: CAPTCHA verification failed. Please try again. (${error.message})`;
            } else if (
              error.message.includes("missing") ||
              error.message.includes("expired")
            ) {
              statusElement.textContent = `Error: CAPTCHA challenge failed or expired. Please wait and try again. (${error.message})`;
            } else {
              statusElement.textContent = `Error: ${error.message || "An unexpected error occurred."}`;
            }
            statusElement.style.color = "red";
          }
          resetTurnstileWidget(form);
        };

        const options: FormSubmitOptions = {
          formElement: form,
          statusElement: statusDiv,
          submitButton: submitButton,
          preparePayload: preparePayloadForOrder,
          onSuccess: onOrderSuccess,
          onError: onOrderError,
          submittingText: "Submitting Order...",
          submitText: "Submit Order",
        };

        await submitFormData(options);
      } catch (authError: any) {
        console.error("Anonymous auth error:", authError);
        if (statusDiv) {
          statusDiv.textContent = `Error: ${authError.message || "Failed to prepare session."}`;
          statusDiv.style.color = "red";
        }
        if (submitButton) {
          submitButton.disabled = false;
          submitButton.textContent =
            submitButton.dataset.originalText || "Submit Order";
        }
        resetTurnstileWidget(form);
      }
    });
  } else {
    console.error(
      "Could not find all required elements (form, name, phone, submit, status) for the order form script.",
    );
  }
</script>

```
---

`src/pages/signin.astro`:
```
---
// src/pages/signin.astro
import Layout from "../layout/Layout.astro";
const title = "Sign In";
---

<Layout title={title}>
  <main>
    <section>
      <h1>{title}</h1>
      <p>
        Use Google to sign in to your account.
      </p>
      <form
        action="/api/auth/signin"
        method="post"
      >
        <button
          value="google"
          name="provider"
          type="submit"
        >
           Sign in with Google
        </button>
      </form>
    </section>
  </main>
</Layout>
```
---

`src/pages/api/auth/anonymous.ts`:
```
// src/pages/api/auth/anonymous.ts
import type { APIRoute } from "astro";
import { supabase } from "../../../lib/supabase";
import { setAuthCookies } from '../../../utils/auth';
import { jsonResponse, jsonErrorResponse } from '../../../utils/apiResponse'; // <-- IMPORT ADDED
// Using constants for cookie names
import { ACCESS_TOKEN_COOKIE, REFRESH_TOKEN_COOKIE } from '../../../utils/constants';

export const POST: APIRoute = async ({ cookies }) => {
  // Check for *existing*, *valid* tokens before attempting a new anonymous sign-in.
  const existingAccessToken = cookies.get(ACCESS_TOKEN_COOKIE);
  const existingRefreshToken = cookies.get(REFRESH_TOKEN_COOKIE);

  if (existingAccessToken?.value && existingRefreshToken?.value) {
     console.log("Anonymous Route: Found existing tokens. Verifying session...");
     const { data: { user } } = await supabase.auth.getUser(existingAccessToken.value);
     if (user) {
        console.log(`Anonymous Route: Existing session is valid for user ${user.id}. Skipping new anonymous sign-in.`);
        // Use utility function for success response
        return jsonResponse(200, { message: "Already authenticated anonymously", userId: user.id }); // <-- UPDATED
     } else {
        console.log("Anonymous Route: Existing session token is invalid or expired. Proceeding with sign-in.");
     }
  } else {
      console.log("Anonymous Route: No existing auth tokens found or incomplete pair.");
  }

  console.log("Anonymous Route: Attempting server-side anonymous sign-in...");
  const { data, error } = await supabase.auth.signInAnonymously();

  if (error || !data?.session || !data?.user) {
    console.error("Anonymous Route: Server-side anonymous sign-in error:", error);
    // Use utility function for error response
    return jsonErrorResponse(500, error?.message || "Anonymous sign-in failed"); // <-- UPDATED
  }

  console.log(`Anonymous Route: Server-side anonymous sign-in successful for user ${data.user.id}. Setting cookies.`);

  setAuthCookies(cookies, data.session);

  // Use utility function for success response
  return jsonResponse(200, { message: "Anonymous sign-in successful", userId: data.user.id }); // <-- UPDATED
};
```
---

`src/pages/api/auth/callback.ts`:
```
import type { APIRoute } from "astro";
import { supabase } from "../../../lib/supabase";
import { setAuthCookies } from '../../../utils/auth';
import { jsonErrorResponse } from '../../../utils/apiResponse'; // <-- IMPORT ADDED

export const GET: APIRoute = async ({ url, cookies, redirect }) => {
  const authCode = url.searchParams.get("code");

  if (!authCode) {
    // Use utility function for error response
    return jsonErrorResponse(400, "No code provided"); // <-- UPDATED
  }

  const { data, error } = await supabase.auth.exchangeCodeForSession(authCode);

  if (error) {
    console.error("Auth Callback Error:", error.message);
    // Use utility function for error response
    return jsonErrorResponse(500, error.message); // <-- UPDATED
  }

  if (!data.session) {
      console.error("Auth Callback Error: No session data returned after code exchange.");
      // Use utility function for error response
      return jsonErrorResponse(500, "Failed to establish session."); // <-- UPDATED
  }

  setAuthCookies(cookies, data.session);

  // Redirect remains unchanged
  return redirect("/dashboard");
};
```
---

`src/pages/api/auth/signin.ts`:
```
import type { APIRoute } from "astro";
import { supabase } from "../../../lib/supabase";
import type { Provider } from "@supabase/supabase-js";
import { AUTH_CALLBACK_PATH } from "../../../utils/constants";
import { jsonErrorResponse } from '../../../utils/apiResponse'; // <-- IMPORT ADDED

export const POST: APIRoute = async ({ request, cookies, redirect, url }) => {
  const formData = await request.formData();
  const provider = formData.get("provider")?.toString();

  const redirectUrl = `${url.origin}${AUTH_CALLBACK_PATH}`;

  if (provider === "google") {
    const { data, error } = await supabase.auth.signInWithOAuth({
      provider: provider as Provider,
      options: {
        redirectTo: redirectUrl,
      },
    });

    if (error) {
      console.error("OAuth Error:", error.message);
      // Use utility function for error response
      return jsonErrorResponse(500, error.message); // <-- UPDATED
    }

    // Redirect remains unchanged
    return redirect(data.url);
  }
  // Use utility function for error response
  return jsonErrorResponse(400, "Invalid sign-in method"); // <-- UPDATED
};
```
---

`src/pages/api/auth/signout.ts`:
```
import type { APIRoute } from "astro";
import { deleteAuthCookies } from '../../../utils/auth'; // <-- IMPORT ADDED

export const GET: APIRoute = async ({ cookies, redirect }) => {
  // Use the utility function to delete cookies
  deleteAuthCookies(cookies); // <-- REPLACED manual deletes

  return redirect("/signin");
};
```
---

`src/pages/api/guestbook/index.ts`:
```
// src/pages/api/guestbook/index.ts
import type { APIRoute } from "astro";
import { getAllGuestbookEntries, createGuestbookEntry } from "../../../services/guestbook.service";
import type { GuestbookEntry } from "../../../types/types";
import { jsonResponse, jsonErrorResponse } from '../../../utils/apiResponse';

// GET handler remains unchanged
export const GET: APIRoute = async () => {
  console.log("API Route: GET /api/guestbook invoked.");
  try {
    const entries = await getAllGuestbookEntries();
    return jsonResponse(200, entries);
  } catch (error: any) {
    console.error("API Error (GET /api/guestbook):", error.message);
    return jsonErrorResponse(500, "Failed to retrieve guestbook entries.");
  }
};

export const POST: APIRoute = async ({ request, locals }) => {
  console.log("API Route: POST /api/guestbook invoked.");

  // --- OPTIMIZATION ---
  // The middleware already ensures that locals.userId is present for this route.
  // We can safely use the non-null assertion operator (!).
  // The redundant check 'if (!userId) { ... }' has been removed.
  const userId = locals.userId!;
  console.log(`API Route: User authenticated via middleware. User ID: ${userId}. Ready to create guestbook entry.`);
  // --- END OPTIMIZATION ---

  try {
    let name: string;
    let message: string;
    try {
        const body: Partial<GuestbookEntry> = await request.json();
        name = body.name?.toString().trim() ?? '';
        message = body.message?.toString().trim() ?? '';

        if (!name || !message) {
            console.log("API Error: Missing or empty name or message in request body.");
            return jsonErrorResponse(400, "Bad Request: Name and message are required and cannot be empty.");
        }
    } catch (e) {
        console.log("API Error: Invalid JSON body received.");
        return jsonErrorResponse(400, "Bad Request: Invalid JSON body.");
    }

    // Note: userId isn't directly used by createGuestbookEntry in this example,
    // but it confirms the user is authenticated as required by the middleware.
    const newEntry = await createGuestbookEntry(name, message);

    console.log("API Route: Guestbook entry created successfully.");
    return jsonResponse(201, newEntry);

  } catch (error: any) {
    console.error("API Error (POST /api/guestbook):", error.message);

    // Error handling remains the same
    if (error.message.startsWith("Validation Error:")) {
         return jsonErrorResponse(400, error.message);
    }
    if (error.message.startsWith("Permission Denied:")) {
         return jsonErrorResponse(403, error.message);
    }
     if (error.message.startsWith("Database Error:")) {
         return jsonErrorResponse(500, "Failed to submit guestbook entry due to a server error.");
     }
    return jsonErrorResponse(500, "An unexpected error occurred while submitting the guestbook entry.");
  }
};
```
---

`src/pages/api/orders/create.ts`:
```
// src/pages/api/orders/create.ts
import type { APIRoute } from "astro";
import { createOrder } from "../../../services/order.service";
import { verifyTurnstileToken } from '../../../utils/turnstile'; // <-- IMPORT the new utility
import { jsonResponse, jsonErrorResponse } from '../../../utils/apiResponse';

// TURNSTILE_SECRET_KEY is no longer needed here

export const POST: APIRoute = async ({ request, locals, clientAddress }) => {
  console.log("API Route: POST /api/orders/create invoked.");

  // --- Authentication Check (remains the same) ---
  const userId = locals.userId!; // Asserting non-null based on middleware guarantee
  console.log(`API Route: User authenticated via middleware. User ID: ${userId}`);
  // ---

  // --- Request Body Parsing & Validation (remains the same) ---
  let ordererName: string | undefined;
  let turnstileToken: string | undefined;
  try {
    interface OrderRequestBody {
        orderer_name?: string;
        turnstileToken?: string; // Field name from client-side payload
    }
    const body: OrderRequestBody = await request.json();
    ordererName = body.orderer_name?.toString().trim();
    turnstileToken = body.turnstileToken?.toString(); // Extract token

    if (!ordererName) {
        console.log("API Error: Missing or empty orderer_name in request body.");
        return jsonErrorResponse(400, "Bad Request: Orderer name is required.");
    }
    if (!turnstileToken) {
        console.log("API Error: Missing turnstileToken in request body.");
        return jsonErrorResponse(400, "Bad Request: CAPTCHA token is missing.");
    }
  } catch (error) {
    console.log("API Error: Invalid JSON body received.");
    return jsonErrorResponse(400, "Bad Request: Invalid JSON body.");
  }
  // ---

  // --- Turnstile Verification (using the new utility) ---
  try {
    console.log("API Route: Calling Turnstile verification utility...");
    // Get client IP (handle potential proxy headers like Netlify's)
    const forwardedIp = request.headers.get('x-nf-client-connection-ip');
    const remoteIp = forwardedIp || clientAddress;

    // Call the abstracted verification function
    await verifyTurnstileToken(turnstileToken, remoteIp);

    console.log("API Route: Turnstile verification successful.");

  } catch (error: any) {
    console.warn("API Route: Turnstile verification failed.", error.message);
    // Check for specific configuration error
    if (error.message.startsWith("Server configuration error")) {
        return jsonErrorResponse(500, error.message);
    }
    // Treat other errors as client-side verification failures (403 Forbidden)
    return jsonErrorResponse(403, `CAPTCHA verification failed: ${error.message}`);
  }
  // ---

  // --- Order Creation (remains the same) ---
  try {
    console.log(`API Route: Calling createOrder service for user ${userId} with name ${ordererName}`);
    const newOrder = await createOrder(userId, ordererName);
    console.log("API Route: Order created successfully:", newOrder.id);
    return jsonResponse(201, newOrder);

  } catch (error: any) {
    console.error("API Error (POST /api/orders/create - Service Call):", error.message);
    // Specific error handling based on service errors (remains the same)
    if (error.message.startsWith("Validation Error:")) {
        return jsonErrorResponse(400, error.message);
    }
    // ... other specific service error checks ...
    if (error.message.startsWith("Database Error:")) {
         return jsonErrorResponse(500, "Failed to create order due to a server database error.");
    }
    return jsonErrorResponse(500, "An unexpected server error occurred while creating the order.");
  }
};
```
---

`src/scripts/formHandler.ts`:
```
// src/utils/formHandler.ts
import type { FormSubmitOptions } from '../types/types';

export async function submitFormData(options: FormSubmitOptions): Promise<void> {
  const {
    formElement, // Needed for reset on success
    statusElement,
    submitButton,
    preparePayload,
    onSuccess,
    onError,
    endpoint = formElement.action,
    method = formElement.method || 'POST',
    submittingText = 'Submitting...',
    submitText = submitButton?.dataset.originalText || 'Submit', // Use data attribute or default
  } = options;

  // Store original text if not already done
  if (submitButton && !submitButton.dataset.originalText) {
      submitButton.dataset.originalText = submitButton.textContent || 'Submit';
  }
  const originalButtonText = submitButton?.dataset.originalText || 'Submit';

  // Clear previous status
  if (statusElement) {
    statusElement.textContent = '';
    statusElement.style.color = 'inherit';
  }

  // Prepare payload - validation happens here
  const payload = preparePayload();
  if (payload === null) {
    // Validation failed, message should be handled by preparePayload/onError caller
    // Ensure button is re-enabled if it was disabled before this check
     if (submitButton && submitButton.disabled) {
        submitButton.disabled = false;
        submitButton.textContent = originalButtonText;
     }
    return; // Exit early
  }

  // Manage UI state: Disable button
  if (submitButton) {
    submitButton.disabled = true;
    submitButton.textContent = submittingText;
  }

  try {
    const response = await fetch(endpoint, {
      method: method.toUpperCase(),
      headers: {
        'Content-Type': 'application/json',
        'Accept': 'application/json',
      },
      body: JSON.stringify(payload),
    });

    let data;
    try {
      // Attempt to parse JSON, works even for errors if body is JSON
      data = await response.json();
    } catch (jsonError) {
      // Handle cases where response is not JSON (e.g., 500 HTML error page)
      if (!response.ok) {
        // Throw generic HTTP error if parsing failed on an error response
        throw new Error(`HTTP error! Status: ${response.status}, Response not JSON.`);
      }
      // If response was ok but not JSON, might be unexpected. Log and treat as success with no data.
      console.warn("Response was OK but not valid JSON.");
      data = null; // Success, but no data parsed
    }

    if (!response.ok) {
      // Use error message from parsed JSON body if available, otherwise default
      const errorMessage = data?.error || `HTTP error! Status: ${response.status}`;
      throw new Error(errorMessage);
    }

    // Call the success callback
    onSuccess(data, formElement);

  } catch (error: any) {
    console.error('Form submission error:', error);
    // Call the error callback
    onError(error, statusElement);
    // Note: error is not re-thrown here, allowing the flow to complete in finally.
    // The onError callback is responsible for user feedback.

  } finally {
    // Re-enable button and restore text in finally block to ensure it always happens
    if (submitButton) {
      submitButton.disabled = false;
      submitButton.textContent = originalButtonText;
    }
  }
}

/**
 * Sets up a standard event listener for form submission that calls submitFormData.
 * Use this for simple forms without pre-submission steps like auth checks.
 * @param options - Configuration for the form submission.
 */
export function setupFormSubmitListener(options: FormSubmitOptions): void {
   const { formElement } = options;
   if (!formElement) {
       console.error('Form submission listener requires a formElement.');
       return;
   }

   formElement.addEventListener('submit', async (event) => {
        event.preventDefault();
        // Directly call the async submission logic
        await submitFormData(options);
   });
}

/**
 * Helper function to reset a Cloudflare Turnstile widget within a given form.
 * @param formElement - The form containing the Turnstile widget.
 */
export function resetTurnstileWidget(formElement: HTMLFormElement | null): void {
    if (!formElement) return;
    try {
        // Find the widget using its class
        const widgetElement = formElement.querySelector<HTMLElement>('.cf-turnstile');
        if (widgetElement && typeof (window as any).turnstile?.reset === 'function') {
           (window as any).turnstile.reset(widgetElement);
           console.log("Turnstile widget reset.");
        }
    } catch (e) {
        console.warn("Could not reset Turnstile widget", e);
    }
}
```
---

`src/services/guestbook.service.ts`:
```
// src/services/guestbook.service.ts
import { supabase } from '../lib/supabase'; // Import the initialized client
import type { GuestbookEntry } from '../types/types'; // Use our defined type
import { handleSupabaseError } from '../utils/supabaseUtils'; // <-- IMPORT ADDED

/**
 * Fetches all guestbook entries, ordered by creation date (ascending).
 * Throws an error if the Supabase query fails.
 */
export async function getAllGuestbookEntries(): Promise<GuestbookEntry[]> {
  const operationContext = "fetch guestbook entries";
  console.log(`Service: ${operationContext}...`);

  const { data, error } = await supabase
    .from("guestbook")
    .select("name, message") // Select only needed fields defined in the type
    .order("created_at", { ascending: true }); // Or false based on desired display order

  // Use the utility function to handle potential errors
  handleSupabaseError(error, operationContext); // <-- REPLACED if(error) block

  // If handleSupabaseError didn't throw, the operation was successful (though data might be empty)
  console.log("Service: Fetched entries successfully.");
  return data as GuestbookEntry[];
}

/**
 * Creates a new guestbook entry.
 * Throws an error if validation fails or the Supabase insert operation fails.
 * @param name - The name of the poster.
 * @param message - The message content.
 * @returns The newly created guestbook entry (only name and message).
 */
export async function createGuestbookEntry(name: string, message: string): Promise<GuestbookEntry> {
  // Basic validation within the service (remains unchanged)
  if (!name || !message || name.trim().length === 0 || message.trim().length === 0) {
      throw new Error("Validation Error: Name and message cannot be empty.");
  }

  const trimmedName = name.trim();
  const trimmedMessage = message.trim();
  const operationContext = "create guestbook entry";

  console.log(`Service: Creating guestbook entry for '${trimmedName}'...`);
  const { data, error } = await supabase
    .from("guestbook")
    .insert({ name: trimmedName, message: trimmedMessage })
    .select("name, message") // Select the fields matching GuestbookEntry type
    .single(); // Expecting a single row back after insert

  // Use the utility function to handle potential errors
  handleSupabaseError(error, operationContext); // <-- REPLACED if(error) block

  // If handleSupabaseError didn't throw, check if data was returned (safeguard)
  if (!data) {
      // This case should ideally not be reached if insert succeeded without error,
      // but acts as a safeguard.
      throw new Error(`Database Error: Failed to ${operationContext}: No data returned after insert.`);
  }

  console.log("Service: Created entry successfully.");
  return data as GuestbookEntry; // Return data matching the type
}
```
---

`src/services/order.service.ts`:
```
// src/services/order.service.ts
import { supabase } from '../lib/supabase';
import type { Order } from '../types/types'; // Import the Order type
import { handleSupabaseError } from '../utils/supabaseUtils';

/**
 * Creates a new order associated with a user ID.
 * Throws an error if validation fails or the Supabase insert operation fails.
 * @param userId - The authenticated user's ID (can be anonymous user ID).
 * @param ordererName - The name provided for the order.
 * @param phone - The phone number provided for the order (optional). // UPDATED DOC
 * @returns The newly created order data.
 */
// UPDATED: Function signature to accept optional phone
export async function createOrder(userId: string, ordererName: string, phone?: string): Promise<Order> {
    // Basic validation
    if (!userId || !ordererName || ordererName.trim().length === 0) {
        throw new Error("Validation Error: User ID and a non-empty Orderer Name are required to create an order.");
    }
    // Optional: Add more specific validation for phone format here if needed

    const trimmedOrdererName = ordererName.trim();
    // Trim phone only if it exists, otherwise ensure it's undefined/null
    const trimmedPhone = phone?.trim() || undefined;
    const operationContext = "create order";

    // UPDATED: Logging to include phone
    console.log(`Service: Creating order for user '${userId}' with name '${trimmedOrdererName}' and phone '${trimmedPhone || 'N/A'}'...`);

    // Prepare data for insertion, using Partial<Order> for better type checking
    const insertData: Partial<Order> & { user_id: string; orderer_name: string; status: Order['status'] } = {
      user_id: userId,
      orderer_name: trimmedOrdererName,
      status: "pending", // Set default status
      // Intentionally omit other fields unless they have default values to set here
    };

    // Conditionally add phone to the insert object only if it has a value
    if (trimmedPhone) {
      insertData.phone = trimmedPhone;
    }
    // Similarly, add other optional fields here if they are passed and have values

    console.log("Service: Inserting data:", insertData); // Log the object being sent to Supabase

    const { data, error } = await supabase
      .from("orders")
      // UPDATED: Use the prepared insertData object
      .insert(insertData)
      .select() // Select all fields defined in the Order type (should now include phone)
      .single(); // Expecting one row back

    // Use the utility function to handle potential errors
    handleSupabaseError(error, operationContext);

     // If handleSupabaseError didn't throw, check if data was returned (safeguard)
     if (!data) {
      // Safeguard against unexpected null data after successful insert
      throw new Error(`Database Error: Failed to ${operationContext}: No data returned after insert.`);
     }

    console.log("Service: Created order successfully with ID:", data.id);
    // The returned 'data' object from Supabase should include the 'phone' field
    // if it was successfully inserted according to the .select()
    return data as Order;
}

// Potential future functions:
// export async function getOrderById(orderId: number): Promise<Order | null> { ... }
// export async function updateOrderStatus(orderId: number, status: Order['status']): Promise<Order> { ... }
// export async function getOrdersByUserId(userId: string): Promise<Order[]> { ... }
```
---

`src/types/types.ts`:
```
// src/types/types.ts

// Existing GuestbookEntry type
export interface GuestbookEntry {
  name: string;
  message: string;
  // Consider adding id and created_at if you fetch/use them
  // id?: number | string;
  // created_at?: string;
}

// Updated Order type
export interface Order {
  id: number; // Or string if you use UUIDs
  user_id: string; // Foreign key to auth.users
  orderer_name: string;
  status: "pending" | "processing" | "completed" | "cancelled"; // Example statuses
  created_at: string; // ISO timestamp string
  phone?: string | null; // ADDED: Optional phone field
  // Add any other relevant fields from your orders table based on schema
  page_count?: number | null;
  total_price?: number | null; // Assuming bigint maps to number safely for JS
  package_tier?: string | null;
  uploaded_file_urls?: any | null; // Use a more specific type if possible
}

// FormSubmitOptions interface remains unchanged
export interface FormSubmitOptions {
  formElement: HTMLFormElement;
  statusElement: HTMLElement | null;
  submitButton: HTMLButtonElement | null;
  // Function to extract and validate data before sending
  // Returns null if validation fails and status should not proceed.
  preparePayload: () => Record<string, any> | null;
  // Callbacks for custom actions on success/error
  onSuccess: (data: any, formElement: HTMLFormElement) => void;
  onError: (error: Error, statusElement: HTMLElement | null) => void;
  // Optional: Use form's action/method by default if not provided
  endpoint?: string;
  method?: string;
  // Optional: Customize button text during submission
  submittingText?: string;
  submitText?: string; // Optional: Text to restore button to (defaults to initial text)
}
```
---

`src/utils/apiResponse.ts`:
```
// src/utils/apiResponse.ts
import type { APIContext } from 'astro';

const commonHeaders = {
    'Content-Type': 'application/json',
};

/**
 * Creates a standardized JSON success response.
 * @param status - HTTP status code (e.g., 200, 201).
 * @param data - The payload to be stringified and sent.
 * @returns A Response object.
 */
export function jsonResponse(status: number, data: any): Response {
    return new Response(JSON.stringify(data), {
        status: status,
        headers: commonHeaders,
    });
}

/**
 * Creates a standardized JSON error response.
 * @param status - HTTP status code (e.g., 400, 401, 403, 404, 500).
 * @param message - The error message.
 * @returns A Response object with { error: message } payload.
 */
export function jsonErrorResponse(status: number, message: string): Response {
    return new Response(JSON.stringify({ error: message }), {
        status: status,
        headers: commonHeaders,
    });
}

// Example of a more detailed error structure if needed in the future:
/*
export function jsonDetailedErrorResponse(status: number, message: string, details?: any): Response {
    return new Response(JSON.stringify({ error: { message, details } }), {
        status: status,
        headers: commonHeaders,
    });
}
*/
```
---

`src/utils/auth.ts`:
```
// src/utils/auth.ts
import type { Session } from '@supabase/supabase-js';
import type { AstroCookies } from 'astro';
import { ACCESS_TOKEN_COOKIE, REFRESH_TOKEN_COOKIE } from './constants'; // <-- IMPORT ADDED

/**
 * Sets the Supabase access and refresh token cookies with consistent security attributes.
 * @param cookies - The Astro cookies object from APIContext or MiddlewareAPIContext.
 * @param session - The Supabase session object containing tokens and expiration info.
 */
export function setAuthCookies(cookies: AstroCookies, session: Session | null | undefined): void {
  // Ensure we have a session and tokens before proceeding
  if (!session?.access_token || !session?.refresh_token) {
      console.warn("setAuthCookies called without a valid session or tokens. Skipping cookie setting.");
      return;
  }

  const { access_token, refresh_token, expires_in } = session;

  const baseCookieOptions = {
    path: "/",
    sameSite: "lax" as const,
    secure: import.meta.env.PROD,
    httpOnly: true,
  };

  const rawAccessTokenMaxAge = (expires_in != null && expires_in > 0) ? expires_in : 3600;
  const accessTokenMaxAge = Math.floor(rawAccessTokenMaxAge);

  const refreshTokenMaxAge = 60 * 60 * 24 * 7; // 7 days in seconds

  if (accessTokenMaxAge <= 0) {
      console.warn(`Calculated accessTokenMaxAge is invalid (${accessTokenMaxAge}). Using default 3600.`);
  }

  console.log(`Setting auth cookies. Access token maxAge: ${accessTokenMaxAge}s`);

  // Use constants for cookie names
  cookies.set(ACCESS_TOKEN_COOKIE, access_token, { // <-- UPDATED
    ...baseCookieOptions,
    maxAge: accessTokenMaxAge,
  });

  cookies.set(REFRESH_TOKEN_COOKIE, refresh_token, { // <-- UPDATED
    ...baseCookieOptions,
    maxAge: refreshTokenMaxAge,
  });
}

/**
 * Deletes the Supabase authentication cookies.
 * @param cookies - The Astro cookies object.
 */
export function deleteAuthCookies(cookies: AstroCookies): void {
    console.log("Deleting auth cookies.");
    // Use constants for cookie names
    cookies.delete(ACCESS_TOKEN_COOKIE, { path: "/" }); // <-- UPDATED
    cookies.delete(REFRESH_TOKEN_COOKIE, { path: "/" }); // <-- UPDATED
}
```
---

`src/utils/constants.ts`:
```
// src/constants.ts

// Cookie Names
export const ACCESS_TOKEN_COOKIE = "sb-access-token";
export const REFRESH_TOKEN_COOKIE = "sb-refresh-token";

// API Paths
export const AUTH_CALLBACK_PATH = "/api/auth/callback";

// External Services Endpoints
export const TURNSTILE_VERIFY_ENDPOINT = 'https://challenges.cloudflare.com/turnstile/v0/siteverify';

// Add other constants here as needed, e.g.:
// export const PROTECTED_PATHS = ["/dashboard"];
// export const REDIRECT_PATHS = ["/signin"];
// export const PROTECTED_API_PATHS = ["/api/guestbook", "/api/orders/create"];
```
---

`src/utils/supabaseUtils.ts`:
```
// src/utils/supabaseUtils.ts
import type { PostgrestError } from '@supabase/supabase-js';

/**
 * Handles common Supabase Postgrest errors, logs them, and throws standardized Error objects.
 *
 * @param error - The PostgrestError object returned from a Supabase query, or null/undefined if no error occurred.
 * @param context - A string describing the operation context (e.g., "fetch guestbook entries", "create order") for clearer error messages.
 * @throws {Error} Throws a standardized error ('Permission Denied', 'Database Error') if the input `error` is not null/undefined.
 */
export function handleSupabaseError(error: PostgrestError | null | undefined, context: string): void {
  if (!error) {
    // No error occurred, do nothing.
    return;
  }

  // Log the original error for debugging purposes
  console.error(`Service Error (${context}):`, error);

  // Handle specific, known error codes
  if (error.code === '42501') { // RLS violation
    throw new Error(`Permission Denied: Cannot ${context}. Check RLS policies.`);
  }

  // Handle other database-related errors generically
  // Add more specific error code checks here if needed in the future
  // e.g., if (error.code === '23505') { throw new Error(`Database Error: Unique constraint violation during ${context}.`); }

  // Fallback for any other database error
  throw new Error(`Database Error: Failed to ${context}: ${error.message}`);
}
```
---

`src/utils/turnstile.ts`:
```
// src/utils/turnstile.ts
import { TURNSTILE_VERIFY_ENDPOINT } from './constants'; // Assuming you move the constant here
import { jsonErrorResponse } from './apiResponse'; // Or just throw errors

const TURNSTILE_SECRET_KEY = import.meta.env.TURNSTILE_SECRET_KEY;

/**
 * Verifies a Cloudflare Turnstile token.
 * Throws an error if verification fails or if the server is misconfigured.
 *
 * @param token - The `cf-turnstile-response` token from the client.
 * @param remoteIp - The client's IP address (optional but recommended).
 * @throws {Error} If the secret key is missing, the fetch fails, or verification is unsuccessful.
 */
export async function verifyTurnstileToken(token: string, remoteIp?: string): Promise<void> {
    if (!TURNSTILE_SECRET_KEY) {
        console.error("Turnstile Verification Error: TURNSTILE_SECRET_KEY is not set.");
        // Throw an error that the API route can catch and translate to a 500
        throw new Error("Server configuration error: CAPTCHA secret missing.");
    }

    if (!token) {
         throw new Error("CAPTCHA token is missing."); // Or handle this validation earlier
    }

    console.log("Util: Verifying Turnstile token...");
    const verifyPayload = new URLSearchParams();
    verifyPayload.append('secret', TURNSTILE_SECRET_KEY);
    verifyPayload.append('response', token);

    if (remoteIp) {
        verifyPayload.append('remoteip', remoteIp);
        console.log("Util: Verifying Turnstile with remoteip:", remoteIp);
    } else {
        console.warn("Util: Verifying Turnstile without remoteip.");
    }

    try {
        const verifyResponse = await fetch(TURNSTILE_VERIFY_ENDPOINT, {
            method: 'POST',
            body: verifyPayload,
        });

        if (!verifyResponse.ok) {
             // Handle non-2xx responses from Cloudflare endpoint
             throw new Error(`Turnstile endpoint returned status ${verifyResponse.status}`);
        }

        const verifyOutcome = await verifyResponse.json();
        console.log("Util: Turnstile verification outcome:", verifyOutcome);

        if (!verifyOutcome.success) {
            // Throw a specific error that the API route can catch
            throw new Error(`Verification failed. Codes: ${(verifyOutcome['error-codes'] || []).join(', ')}`);
        }

        console.log("Util: Turnstile verification successful for hostname:", verifyOutcome.hostname);
        // If successful, the function completes without returning anything (void)

    } catch (error: any) {
        console.error("Util Error: Exception during Turnstile verification fetch:", error);
        // Re-throw or throw a new standardized error
        throw new Error(`Server error during CAPTCHA verification: ${error.message}`);
    }
}
```
---
