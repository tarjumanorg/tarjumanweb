---

`astro.config.mjs`:
```
import { defineConfig } from 'astro/config';
import netlify from '@astrojs/netlify';

export default defineConfig({
  site: 'https://tarjuman.netlify.app',
  output: 'server',
  adapter: netlify(),

});
```
---

`tsconfig.json`:
```
{
  "extends": "astro/tsconfigs/strict",
  "include": [".astro/types.d.ts", "**/*"],
  "exclude": ["dist"]
}

```
---

`src/env.d.ts`:
```
declare namespace App {
  interface Locals {
    email: string;
  }
}
```
---

`src/components/Reviews.astro`:
```
---
// src/components/Reviews.astro
import type { GuestbookEntry } from "../types/types";

interface Props {
  reviews: GuestbookEntry[];
}

const { reviews } = Astro.props;
---

<div>
  <form
    id="guestbook-form"
    method="post"
    action="/api/guestbook"
  >
    <h3 >Leave a message</h3>


    <div id="form-status"></div>

    <div >
      <label
        for="name"
      >
        Name
      </label>
      <input
        id="name"
        type="text"
        placeholder="Your Name"
        required
        name="name"
            />
    </div>
    <div >
      <label
        for="message"
              >
        Message
      </label>

      <input
        id="message"
        type="text"
        placeholder="A friendly message..."
        required
        name="message"
           />
    </div>
    <button
      id="submit-button"
      type="submit"
        >
      Submit
    </button>
  </form>

  <h3>Guestbook Entries</h3>
   <div id="reviews-list">
    {reviews.length > 0 ? (
        <ul>
        {reviews.map((review) => (
            <li>
            <p>
              
                {review.name}

            </p>
            <p>{review.message}</p>
            </li>
        ))}
        </ul>
    ) : (
        <p>No reviews yet. Be the first!</p>
    )}
   </div>
</div>

<script>
  const form = document.getElementById('guestbook-form') as HTMLFormElement;
  const nameInput = document.getElementById('name') as HTMLInputElement;
  const messageInput = document.getElementById('message') as HTMLInputElement;
  const statusDiv = document.getElementById('form-status');
  const submitButton = document.getElementById('submit-button') as HTMLButtonElement;

  if (form && nameInput && messageInput && statusDiv && submitButton) {
    form.addEventListener('submit', async (event) => {
      event.preventDefault();

      statusDiv.textContent = '';
      submitButton.disabled = true;
      submitButton.textContent = 'Submitting...';

      const name = nameInput.value;
      const message = messageInput.value;

      const payload = JSON.stringify({ name, message });

      try {
        const response = await fetch(form.action, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'Accept': 'application/json',
          },
          body: payload,
        });


        const data = await response.json(); 

        if (!response.ok) {
          throw new Error(data.error || `HTTP error! Status: ${response.status}`);
        }

        statusDiv.textContent = 'Message submitted successfully!';
        form.reset();

      } catch (error: any) {
        console.error('Submission error:', error);
        statusDiv.textContent = `Error: ${error.message || 'Could not submit message.'}`;

      } finally {
        submitButton.disabled = false;
        submitButton.textContent = 'Submit';
      }
    });
  } else {
    console.error('Could not find all required form elements for guestbook submission script.');
  }
</script>
```
---

`src/layout/Layout.astro`:
```
---
interface Props {
  title: string;
}

const description = "Astro and Supabase demo app";
const { title } = Astro.props;
const ogImageURL = new URL("hero.png", Astro.site).href;
const canonicalURL = new URL(Astro.url).href;
---

<html lang="en">
  <head>
    <title>{title}</title>
    <meta charset="utf-8" />
    <link rel="icon" type="image/svg+xml" href="/favicon.svg" />
    <meta name="viewport" content="width=device-width" />
    <meta name="generator" content={Astro.generator} />
    <meta name="description" content={description} />
    <meta property="twitter:image" content={ogImageURL} />
    <meta property="twitter:card" content="summary_large_image" />
    <meta property="twitter:title" content={title} />
    <meta property="twitter:description" content={description} />
    <meta property="og:image" content={ogImageURL} />
    <meta property="og:title" content={title} />
    <meta property="og:description" content={description} />
    <meta property="og:url" content={canonicalURL} />
  </head>
  <body>
    <nav>
      <div>
        <a href="/">Astro</a>
        <div>
          <ul>
            <li>
              <a href="/dashboard">Dashboard</a>
            </li>
            <li>
              <a href="/signin">Sign in</a>
            </li>
          </ul>
        </div>
      </div>
    </nav>
    <slot />
  </body>
</html>
```
---

`src/lib/supabase.ts`:
```
// src/lib/supabase.ts
import { createClient } from "@supabase/supabase-js";

const supabaseUrl = import.meta.env.PUBLIC_SUPABASE_URL;
const supabaseAnonKey = import.meta.env.PUBLIC_SUPABASE_ANON_KEY;

if (!supabaseUrl || !supabaseAnonKey) {
  throw new Error("Supabase URL or Anon Key is missing.");
}

export const supabase = createClient(
  supabaseUrl,
  supabaseAnonKey,
  {
    auth: {
      flowType: "pkce",
      autoRefreshToken: true,
      detectSessionInUrl: false,
      persistSession: true,
    },
  },
);
```
---

`src/middleware/index.ts`:
```
// src/middleware/index.ts
import { defineMiddleware } from "astro:middleware";
import { supabase } from "../lib/supabase";

// Define routes clearly
const protectedPaths = ["/dashboard"];
const redirectPaths = ["/signin", "/register"]; // Assuming you might add /register later
// Add the new API route for creating orders
const protectedAPIPaths = ["/api/guestbook", "/api/orders/create"]; // <-- ADDED HERE

// Helper function to check paths, handling optional trailing slash
function matchesPath(pathname: string, pathsToCheck: string[]): boolean {
  const normalizedPathname = pathname.endsWith('/') && pathname.length > 1
    ? pathname.slice(0, -1)
    : pathname;
  return pathsToCheck.includes(normalizedPathname);
}

export const onRequest = defineMiddleware(
  async ({ locals, url, cookies, redirect }, next) => {

    const isProtectedRoute = matchesPath(url.pathname, protectedPaths);

    if (isProtectedRoute) {
      const accessToken = cookies.get("sb-access-token");
      const refreshToken = cookies.get("sb-refresh-token");

      if (!accessToken || !refreshToken) {
        return redirect("/signin");
      }

      const { data, error } = await supabase.auth.setSession({
        refresh_token: refreshToken.value,
        access_token: accessToken.value,
      });

      if (error) {
        cookies.delete("sb-access-token", { path: "/" });
        cookies.delete("sb-refresh-token", { path: "/" });
        return redirect("/signin");
      }

      // Store email in locals for dashboard page
      locals.email = data.user?.email!;

      // Refresh cookies with potentially new tokens and ensure flags are set
      cookies.set("sb-access-token", data?.session?.access_token!, {
        sameSite: "strict",
        path: "/",
        secure: import.meta.env.PROD, // Use secure cookies in production
        httpOnly: true
      });
      cookies.set("sb-refresh-token", data?.session?.refresh_token!, {
        sameSite: "strict",
        path: "/",
        secure: import.meta.env.PROD, // Use secure cookies in production
        httpOnly: true,
      });
    }

    const isRedirectRoute = matchesPath(url.pathname, redirectPaths);

    if (isRedirectRoute) {
      const accessToken = cookies.get("sb-access-token");
      const refreshToken = cookies.get("sb-refresh-token");

      if (accessToken && refreshToken) {
        // Optional: Quick validation before redirecting?
        // For simplicity, just redirect if tokens exist.
        // A robust check might involve supabase.auth.getUser(accessToken.value)
        return redirect("/dashboard");
      }
    }

    const isProtectedAPIRoute = matchesPath(url.pathname, protectedAPIPaths);

    if (isProtectedAPIRoute) {
      const accessToken = cookies.get("sb-access-token");
      const refreshToken = cookies.get("sb-refresh-token"); // Keep refresh token check for robustness

      if (!accessToken) { // Primarily check access token for API calls
         console.log("Middleware: No access token for protected API route");
         return new Response(JSON.stringify({ error: "Unauthorized: Missing token" }), { status: 401 });
      }

      // Validate the access token
      const { data: { user }, error } = await supabase.auth.getUser(accessToken.value);

      if (error || !user) {
        console.log("Middleware: Invalid/Expired token for API route.", error?.message);
        // Attempt refresh only if refresh token exists (though less common for API calls)
        if (refreshToken) {
           const { data: refreshData , error: refreshError } = await supabase.auth.setSession({
                refresh_token: refreshToken.value,
                access_token: accessToken.value, // Include access token for potential validation
           });

            if (refreshError || !refreshData.session) {
                console.log("Middleware: Session refresh failed for API route.");
                cookies.delete("sb-access-token", { path: "/" });
                cookies.delete("sb-refresh-token", { path: "/" });
                return new Response(JSON.stringify({ error: "Unauthorized: Session Refresh Failed" }), { status: 401 });
            }

             // If refresh worked, set new cookies (important!) and proceed
             console.log("Middleware: Session refreshed successfully for API route.");
             cookies.set("sb-access-token", refreshData.session.access_token, {
               sameSite: "strict", path: "/", secure: import.meta.env.PROD, httpOnly: true
             });
             cookies.set("sb-refresh-token", refreshData.session.refresh_token, {
               sameSite: "strict", path: "/", secure: import.meta.env.PROD, httpOnly: true
             });
             // We *could* store the user ID in locals here if needed by multiple API endpoints
             // locals.userId = refreshData.user.id;
             return next(); // Proceed with the refreshed session
        } else {
            // No refresh token, definitely unauthorized
            cookies.delete("sb-access-token", { path: "/" }); // Clean up invalid token
            return new Response(JSON.stringify({ error: "Unauthorized: Invalid Token" }), { status: 401 });
        }
      }
      // If token is valid, proceed.
      // We *could* store the user ID in locals here if needed by multiple API endpoints
      // locals.userId = user.id;
    }

    // If none of the above conditions were met, proceed to the route handler
    return next();
  },
);
```
---

`src/pages/dashboard.astro`:
```
---
// src/pages/dashboard.astro
import Layout from "../layout/Layout.astro";
import { supabase } from "../lib/supabase";
import Reviews from "../components/Reviews.astro";
import type { GuestbookEntry } from "../types/types";

const { email } = Astro.locals;

let reviews: GuestbookEntry[] = [];
let fetchError: string | null = null;

try {
  const { data, error } = await supabase
    .from("guestbook")
    .select("name, message")
    .order("created_at", { ascending: false });

  if (error) {
    throw error;
  }
  reviews = data as GuestbookEntry[];

} catch (e: any) {
   fetchError = `Failed to load reviews: ${e.message}`;
   console.error("Error fetching reviews:", e);
}
---

<Layout title="Dashboard">
  <section>
    <p>
      Logged in as: <strong>{email}</strong>
    </p>
    <p>
      This is a protected page. You can only see this if you are logged in.
    </p>
    <a
      href="/api/auth/signout"
      >Sign out</a
    >

    {fetchError && <p>{fetchError}</p>}

    <Reviews reviews={reviews} />
  </section>
</Layout>
```
---

`src/pages/index.astro`:
```
---
import Layout from "../layout/Layout.astro";
export const prerender = true;
const title = "Supabase and Astro Demo";
---

<Layout title={title}>
  <main>
    <h1>{title}</h1>
    <ul>
      <li
      >
      </li>
       &plus;
      <li
      >
      </li>
    </ul>
    <p>This page was pre-rendered at build time</p>
  </main>
</Layout>

```
---

`src/pages/order.astro`:
```
---
// src/pages/order.astro
import Layout from "../layout/Layout.astro";

const title = "Place Your Order";
---

<Layout title={title}>
  <main>
    <section>
      <h1>{title}</h1>
      <p>Enter your name to start your order.</p>

      <form id="order-form">
        <div>
          <label for="orderer-name">Your Name:</label>
          <input
            type="text"
            id="orderer-name"
            name="orderer_name"
            required
            placeholder="Enter your name"
          />
        </div>

        <div id="order-status" aria-live="polite" style="margin-top: 1rem; min-height: 1.5em;">
          {/* Status messages will appear here */}
        </div>

        <button type="submit" id="submit-order-button" style="margin-top: 1rem;">
          Submit Order
        </button>
      </form>

    </section>
  </main>
</Layout>

<script>
  // Import Supabase client - Ensure PUBLIC keys are used in supabase.ts
  import { supabase } from '../lib/supabase';

  const form = document.getElementById('order-form') as HTMLFormElement | null;
  const nameInput = document.getElementById('orderer-name') as HTMLInputElement | null;
  const submitButton = document.getElementById('submit-order-button') as HTMLButtonElement | null;
  const statusDiv = document.getElementById('order-status');

  if (form && nameInput && submitButton && statusDiv) {
    form.addEventListener('submit', async (event) => {
      event.preventDefault(); // Stop default form submission

      const ordererName = nameInput.value.trim();

      if (!ordererName) {
        statusDiv.textContent = 'Please enter your name.';
        statusDiv.style.color = 'red';
        nameInput.focus();
        return;
      }

      // Disable button and show processing state
      submitButton.disabled = true;
      submitButton.textContent = 'Processing...';
      statusDiv.textContent = 'Processing your request...';
      statusDiv.style.color = 'inherit'; // Reset color

      try {
        // 1. Check if already logged in
        let { data: { session }, error: sessionError } = await supabase.auth.getSession();

        if (sessionError) {
          console.error("Error checking session:", sessionError);
          throw new Error("Could not check authentication status.");
        }

        // 2. If not logged in, sign in anonymously
        if (!session) {
          statusDiv.textContent = 'Signing in anonymously...';
          const { error: signInError } = await supabase.auth.signInAnonymously();

          if (signInError) {
            console.error("Anonymous sign-in error:", signInError);
            throw new Error(`Anonymous sign-in failed: ${signInError.message}`);
          }
          console.log("Anonymous sign-in successful.");
          // Re-fetch session data just to be sure (optional but good practice)
          const { data: { session: newSession }, error: postSignInError } = await supabase.auth.getSession();
          if (postSignInError || !newSession) {
             console.error("Error fetching session after anonymous sign-in:", postSignInError);
             throw new Error("Failed to confirm session after anonymous sign-in.");
          }
          session = newSession; // Use the confirmed session
        } else {
            console.log("User already has a session.");
        }

        // 3. Submit the order data (user is now guaranteed to be authenticated)
        statusDiv.textContent = 'Submitting order...';

        const response = await fetch('/api/orders/create', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'Accept': 'application/json',
          },
          body: JSON.stringify({ orderer_name: ordererName }),
        });

        // Check response status
        if (!response.ok) {
          let errorMsg = `HTTP error! Status: ${response.status}`;
          try {
            // Try to parse error message from API response body
            const errorData = await response.json();
            errorMsg = errorData.error || errorMsg; // Use API error if available
          } catch (parseError) {
            // Ignore if response body is not JSON or empty
          }
          console.error("Order submission failed:", errorMsg);
          throw new Error(`Order submission failed: ${errorMsg}`);
        }

        // Order submitted successfully
        const createdOrder = await response.json();
        console.log("Order created:", createdOrder);
        statusDiv.textContent = `Order submitted successfully! Order ID: ${createdOrder.id}`;
        statusDiv.style.color = 'green';
        form.reset(); // Clear the form

        // Optional: Redirect or update UI further
        // window.location.href = '/dashboard'; // Example redirect


      } catch (error: any) {
        console.error('Order process error:', error);
        statusDiv.textContent = `Error: ${error.message || 'An unexpected error occurred.'}`;
        statusDiv.style.color = 'red';

      } finally {
        // Re-enable the button regardless of success or failure
        submitButton.disabled = false;
        submitButton.textContent = 'Submit Order';
      }
    });
  } else {
    console.error('Could not find all required elements for the order form script.');
  }
</script>
```
---

`src/pages/signin.astro`:
```
---
// src/pages/signin.astro
import Layout from "../layout/Layout.astro";
const title = "Sign In";
---

<Layout title={title}>
  <main>
    <section>
      <h1>{title}</h1>
      <p>
        Use Google to sign in to your account.
      </p>
      <form
        action="/api/auth/signin"
        method="post"
      >
        <button
          value="google"
          name="provider"
          type="submit"
        >
           Sign in with Google
        </button>
      </form>
    </section>
  </main>
</Layout>
```
---

`src/pages/api/guestbook.ts`:
```
import type { APIRoute } from "astro";
import { supabase } from "../../lib/supabase";

export const GET: APIRoute = async () => {
  const { data, error } = await supabase
    .from("guestbook")
    .select("*")
    .order("created_at", { ascending: true });

  if (error) {
    return new Response(
      JSON.stringify({
        error: error.message,
      }),
      { status: 500 },
    );
  }
  
  return new Response(JSON.stringify(data));
};

export const POST: APIRoute = async ({ request }) => {
  const { name, message } = await request.json();
  const { data, error } = await supabase
    .from("guestbook")
    .insert({ name, message })
    .select();

  if (error) {
    return new Response(
      JSON.stringify({
        error: error.message,
      }),
      { status: 500 },
    );
  }

  return new Response(JSON.stringify(data));
};

```
---

`src/pages/api/auth/callback.ts`:
```
import type { APIRoute } from "astro";
import { supabase } from "../../../lib/supabase";

export const GET: APIRoute = async ({ url, cookies, redirect }) => {
  const authCode = url.searchParams.get("code");

  if (!authCode) {
    return new Response("No code provided", { status: 400 });
  }

  const { data, error } = await supabase.auth.exchangeCodeForSession(authCode);

  if (error) {
    return new Response(error.message, { status: 500 });
  }

  const { access_token, refresh_token } = data.session;

  cookies.set("sb-access-token", access_token, {
    path: "/",
    secure: true,
    httpOnly: true,
  });
  cookies.set("sb-refresh-token", refresh_token, {
    path: "/",
    secure: true,
    httpOnly: true,
  });
  return redirect("/dashboard");
};

```
---

`src/pages/api/auth/signin.ts`:
```
import type { APIRoute } from "astro";
import { supabase } from "../../../lib/supabase";
import type { Provider } from "@supabase/supabase-js";

const OAUTH_CALLBACK_PATH = "/api/auth/callback";

export const POST: APIRoute = async ({ request, cookies, redirect, url }) => {
  const formData = await request.formData();
  const provider = formData.get("provider")?.toString();

  const redirectUrl = `${url.origin}${OAUTH_CALLBACK_PATH}`;

  if (provider === "google") {
    const { data, error } = await supabase.auth.signInWithOAuth({
      provider: provider as Provider,
      options: {
        redirectTo: redirectUrl,
      },
    });

    if (error) {
      console.error("OAuth Error:", error.message);
      return new Response(error.message, { status: 500 });
    }

    return redirect(data.url);
  }
  return new Response("Invalid sign-in method", { status: 400 });
};
```
---

`src/pages/api/auth/signout.ts`:
```
import type { APIRoute } from "astro";

export const GET: APIRoute = async ({ cookies, redirect }) => {
  cookies.delete("sb-access-token", { path: "/" });
  cookies.delete("sb-refresh-token", { path: "/" });
  return redirect("/signin");
};

```
---

`src/pages/api/orders/create.ts`:
```
// src/pages/api/orders/create.ts
import type { APIRoute } from "astro";
import { supabase } from "../../../lib/supabase";

export const POST: APIRoute = async ({ request, cookies }) => {
  // 1. Get submitted data
  let ordererName: string | undefined;
  try {
    const data = await request.json();
    ordererName = data.orderer_name?.toString().trim(); // Basic sanitization

    if (!ordererName) {
      return new Response(
        JSON.stringify({ error: "Orderer name is required." }),
        { status: 400 }
      );
    }
  } catch (error) {
    return new Response(
      JSON.stringify({ error: "Invalid request body. Expected JSON." }),
      { status: 400 }
    );
  }


  // 2. Verify authentication and get user ID (Middleware should have run, but double-check)
  const accessToken = cookies.get("sb-access-token");

  if (!accessToken) {
    // This shouldn't happen if middleware is working, but belt-and-suspenders
    return new Response(JSON.stringify({ error: "Unauthorized: Missing token" }), { status: 401 });
  }

  const { data: { user }, error: userError } = await supabase.auth.getUser(accessToken.value);

  if (userError || !user) {
    console.error("API /api/orders/create: Error getting user", userError);
    // Optionally attempt refresh here? Middleware should handle this primarily.
    // For simplicity in the API route, we'll rely on middleware validation.
    return new Response(JSON.stringify({ error: "Unauthorized: Invalid session" }), { status: 401 });
  }

  const userId = user.id;

  // 3. Insert into Database
  try {
    const { data: newOrder, error: insertError } = await supabase
      .from("orders")
      .insert({
        user_id: userId,
        orderer_name: ordererName,
        status: "pending", // Set a default status
        // Add defaults for other required fields if necessary, or handle nulls
        // page_count: 0,
        // total_price: 0,
        // package_tier: 'default',
        // uploaded_file_urls: []
      })
      .select() // Return the created row
      .single(); // Expect only one row back

    if (insertError) {
      console.error("API /api/orders/create: Supabase insert error", insertError);
      // Check for specific errors, e.g., RLS violation
      if (insertError.code === '42501') { // RLS violation code
         return new Response(
            JSON.stringify({ error: "Database permission denied. Check RLS policies." }),
            { status: 403 } // Forbidden
         );
      }
      return new Response(
        JSON.stringify({ error: "Database error: " + insertError.message }),
        { status: 500 }
      );
    }

    // 4. Return Success Response
    return new Response(JSON.stringify(newOrder), { status: 201 }); // 201 Created

  } catch (error: any) {
    console.error("API /api/orders/create: Unexpected error", error);
    return new Response(
      JSON.stringify({ error: "An unexpected error occurred." }),
      { status: 500 }
    );
  }
};
```
---

`src/types/types.ts`:
```
// src/types/types.ts
export interface GuestbookEntry {
    name: string;
    message: string;
  }
```
---
