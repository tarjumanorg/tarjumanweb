---

`astro.config.mjs`:
```
import { defineConfig } from 'astro/config';
import netlify from '@astrojs/netlify';

export default defineConfig({
  site: 'https://tarjuman.netlify.app',
  output: 'server',
  adapter: netlify(),

});
```
---

`tsconfig.json`:
```
{
  "extends": "astro/tsconfigs/strict",
  "include": [".astro/types.d.ts", "**/*"],
  "exclude": ["dist"]
}

```
---

`src/env.d.ts`:
```
declare namespace App {
  interface Locals {
    email: string;
  }
}
```
---

`src/components/Reviews.astro`:
```
---
// src/components/Reviews.astro
import type { GuestbookEntry } from "../types/types";

interface Props {
  reviews: GuestbookEntry[];
}

const { reviews } = Astro.props;
---

<div>
  <form
    id="guestbook-form"
    method="post"
    action="/api/guestbook"
  >
    <h3 >Leave a message</h3>


    <div id="form-status"></div>

    <div >
      <label
        for="name"
      >
        Name
      </label>
      <input
        id="name"
        type="text"
        placeholder="Your Name"
        required
        name="name"
            />
    </div>
    <div >
      <label
        for="message"
              >
        Message
      </label>

      <input
        id="message"
        type="text"
        placeholder="A friendly message..."
        required
        name="message"
           />
    </div>
    <button
      id="submit-button"
      type="submit"
        >
      Submit
    </button>
  </form>

  <h3>Guestbook Entries</h3>
   <div id="reviews-list">
    {reviews.length > 0 ? (
        <ul>
        {reviews.map((review) => (
            <li>
            <p>
              
                {review.name}

            </p>
            <p>{review.message}</p>
            </li>
        ))}
        </ul>
    ) : (
        <p>No reviews yet. Be the first!</p>
    )}
   </div>
</div>

<script>
  const form = document.getElementById('guestbook-form') as HTMLFormElement;
  const nameInput = document.getElementById('name') as HTMLInputElement;
  const messageInput = document.getElementById('message') as HTMLInputElement;
  const statusDiv = document.getElementById('form-status');
  const submitButton = document.getElementById('submit-button') as HTMLButtonElement;

  if (form && nameInput && messageInput && statusDiv && submitButton) {
    form.addEventListener('submit', async (event) => {
      event.preventDefault();

      statusDiv.textContent = '';
      submitButton.disabled = true;
      submitButton.textContent = 'Submitting...';

      const name = nameInput.value;
      const message = messageInput.value;

      const payload = JSON.stringify({ name, message });

      try {
        const response = await fetch(form.action, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'Accept': 'application/json',
          },
          body: payload,
        });


        const data = await response.json(); 

        if (!response.ok) {
          throw new Error(data.error || `HTTP error! Status: ${response.status}`);
        }

        statusDiv.textContent = 'Message submitted successfully!';
        form.reset();

      } catch (error: any) {
        console.error('Submission error:', error);
        statusDiv.textContent = `Error: ${error.message || 'Could not submit message.'}`;

      } finally {
        submitButton.disabled = false;
        submitButton.textContent = 'Submit';
      }
    });
  } else {
    console.error('Could not find all required form elements for guestbook submission script.');
  }
</script>
```
---

`src/layout/Layout.astro`:
```
---
interface Props {
  title: string;
}

const description = "Astro and Supabase demo app";
const { title } = Astro.props;
const ogImageURL = new URL("hero.png", Astro.site).href;
const canonicalURL = new URL(Astro.url).href;
---

<html lang="en">
  <head>
    <title>{title}</title>
    <meta charset="utf-8" />
    <link rel="icon" type="image/svg+xml" href="/favicon.svg" />
    <meta name="viewport" content="width=device-width" />
    <meta name="generator" content={Astro.generator} />
    <meta name="description" content={description} />
    <meta property="twitter:image" content={ogImageURL} />
    <meta property="twitter:card" content="summary_large_image" />
    <meta property="twitter:title" content={title} />
    <meta property="twitter:description" content={description} />
    <meta property="og:image" content={ogImageURL} />
    <meta property="og:title" content={title} />
    <meta property="og:description" content={description} />
    <meta property="og:url" content={canonicalURL} />
  </head>
  <body>
    <nav>
      <div>
        <a href="/">Astro</a>
        <div>
          <ul>
            <li>
              <a href="/dashboard">Dashboard</a>
            </li>
            <li>
              <a href="/signin">Sign in</a>
            </li>
          </ul>
        </div>
      </div>
    </nav>
    <slot />
  </body>
</html>
```
---

`src/lib/supabase.ts`:
```
// src/lib/supabase.ts
import { createClient } from "@supabase/supabase-js";

const supabaseUrl = import.meta.env.PUBLIC_SUPABASE_URL;
const supabaseAnonKey = import.meta.env.PUBLIC_SUPABASE_ANON_KEY;

if (!supabaseUrl || !supabaseAnonKey) {
  throw new Error("Supabase URL or Anon Key is missing.");
}

export const supabase = createClient(
  supabaseUrl,
  supabaseAnonKey,
  {
    auth: {
      flowType: "pkce",
      autoRefreshToken: true,
      detectSessionInUrl: false,
      persistSession: true,
    },
  },
);
```
---

`src/middleware/index.ts`:
```
// src/middleware/index.ts
import { defineMiddleware } from "astro:middleware";
import { supabase } from "../lib/supabase";
import { setAuthCookies, deleteAuthCookies } from '../utils/auth';

const protectedPaths = ["/dashboard"];
const redirectPaths = ["/signin"];
const protectedAPIPaths = ["/api/guestbook", "/api/orders/create"];

function matchesPath(pathname: string, pathsToCheck: string[]): boolean {
  const normalizedPathname = pathname.endsWith('/') && pathname.length > 1
    ? pathname.slice(0, -1)
    : pathname;
  return pathsToCheck.includes(normalizedPathname);
}

export const onRequest = defineMiddleware(
  async ({ locals, url, cookies, redirect }, next) => {

    const isProtectedRoute = matchesPath(url.pathname, protectedPaths);

    if (isProtectedRoute) {
      const accessToken = cookies.get("sb-access-token");
      const refreshToken = cookies.get("sb-refresh-token");

      if (!accessToken || !refreshToken) {
        console.log("Middleware: No tokens for protected route, redirecting to signin.");
        return redirect("/signin");
      }

      const { data, error } = await supabase.auth.setSession({
        refresh_token: refreshToken.value,
        access_token: accessToken.value,
      });

      if (error || !data.session) {
        console.log("Middleware: setSession failed for protected route, deleting cookies and redirecting.", error?.message);
        deleteAuthCookies(cookies);
        return redirect("/signin");
      }

      locals.email = data.user?.email!;

      console.log("Middleware: Session validated/refreshed for protected route, setting cookies.");
      setAuthCookies(cookies, data.session);
    }

    const isRedirectRoute = matchesPath(url.pathname, redirectPaths);

    if (isRedirectRoute) {
      const accessToken = cookies.get("sb-access-token");
      const refreshToken = cookies.get("sb-refresh-token");

      if (accessToken && refreshToken) {
        const { data: { user } } = await supabase.auth.getUser(accessToken.value);
        if(user) {
          console.log("Middleware: User already logged in, redirecting from signin/register to dashboard.");
          return redirect("/dashboard");
        } else {
           console.log("Middleware: User has tokens but token is invalid, clearing cookies on redirect path.");
           deleteAuthCookies(cookies);
        }
      }
    }

    const isProtectedAPIRoute = matchesPath(url.pathname, protectedAPIPaths);

    if (isProtectedAPIRoute) {
      const accessToken = cookies.get("sb-access-token");
      const refreshToken = cookies.get("sb-refresh-token");

      if (!accessToken) {
         console.log("Middleware: No access token for protected API route");
         return new Response(JSON.stringify({ error: "Unauthorized: Missing token" }), { status: 401 });
      }

      const { data: { user }, error } = await supabase.auth.getUser(accessToken.value);

      if (error || !user) {
        console.log("Middleware: Invalid/Expired token for API route.", error?.message);

        if (refreshToken) {
           console.log("Middleware: Attempting token refresh for API route.");
           const { data: refreshData , error: refreshError } = await supabase.auth.setSession({
                refresh_token: refreshToken.value,
                access_token: accessToken.value,
           });

            if (refreshError || !refreshData.session) {
                console.log("Middleware: Session refresh failed for API route. Deleting cookies.");
                deleteAuthCookies(cookies);

                return new Response(JSON.stringify({ error: "Unauthorized: Session Refresh Failed" }), { status: 401 });
            }

             console.log("Middleware: Session refreshed successfully for API route. Setting cookies.");
             setAuthCookies(cookies, refreshData.session);

             return next();
        } else {

             console.log("Middleware: Invalid token for API route and no refresh token found. Deleting cookie.");
            deleteAuthCookies(cookies);
            return new Response(JSON.stringify({ error: "Unauthorized: Invalid Token" }), { status: 401 });
        }
      }
      
      // If token is valid, proceed.
      console.log("Middleware: Valid token found for protected API route.");
      // We *could* store the user ID in locals here if needed by multiple API endpoints
      // locals.userId = user.id;
    }

    return next();
  },
);
```
---

`src/pages/dashboard.astro`:
```
---
// src/pages/dashboard.astro
import Layout from "../layout/Layout.astro";
import { supabase } from "../lib/supabase";
import Reviews from "../components/Reviews.astro";
import type { GuestbookEntry } from "../types/types";

const { email } = Astro.locals;

let reviews: GuestbookEntry[] = [];
let fetchError: string | null = null;

try {
  const { data, error } = await supabase
    .from("guestbook")
    .select("name, message")
    .order("created_at", { ascending: false });

  if (error) {
    throw error;
  }
  reviews = data as GuestbookEntry[];

} catch (e: any) {
   fetchError = `Failed to load reviews: ${e.message}`;
   console.error("Error fetching reviews:", e);
}
---

<Layout title="Dashboard">
  <section>
    <p>
      Logged in as: <strong>{email}</strong>
    </p>
    <p>
      This is a protected page. You can only see this if you are logged in.
    </p>
    <a
      href="/api/auth/signout"
      >Sign out</a
    >

    {fetchError && <p>{fetchError}</p>}

    <Reviews reviews={reviews} />
  </section>
</Layout>
```
---

`src/pages/index.astro`:
```
---
import Layout from "../layout/Layout.astro";
export const prerender = true;
const title = "Supabase and Astro Demo";
---

<Layout title={title}>
  <main>
    <h1>{title}</h1>
    <ul>
      <li
      >
      </li>
       &plus;
      <li
      >
      </li>
    </ul>
    <p>This page was pre-rendered at build time</p>
  </main>
</Layout>

```
---

`src/pages/order.astro`:
```
---
// src/pages/order.astro
import Layout from "../layout/Layout.astro";

const title = "Place Your Order";
// Your Turnstile Site Key (safe to be public)
const turnstileSiteKey = "0x4AAAAAABDz77Fkj-zw6ls4";
---

<Layout title={title}>
  <head>
    <!-- Add Turnstile script in the head -->
    <script src="https://challenges.cloudflare.com/turnstile/v0/api.js" defer></script>
  </head>
  <main>
    <section>
      <h1>{title}</h1>
      <p>Enter your name to start your order.</p>

      <form id="order-form">
        <div>
          <label for="orderer-name">Your Name:</label>
          <input
            type="text"
            id="orderer-name"
            name="orderer_name"
            required
            placeholder="Enter your name"
          />
        </div>

        <!-- Add the Turnstile Widget Div here -->
        <div
          class="cf-turnstile"
          data-sitekey={turnstileSiteKey}
          style="margin-top: 1rem;"
        >
        </div>
        <!-- End Turnstile Widget Div -->

        <div id="order-status" aria-live="polite" style="margin-top: 1rem; min-height: 1.5em;">
          {/* Status messages will appear here */}
        </div>

        <button type="submit" id="submit-order-button" style="margin-top: 1rem;">
          Submit Order
        </button>
      </form>

    </section>
  </main>
</Layout>

<script>
  // No changes needed for supabase import if you keep the server-side anonymous auth
  // import { supabase } from '../lib/supabase';

  const form = document.getElementById('order-form') as HTMLFormElement | null;
  const nameInput = document.getElementById('orderer-name') as HTMLInputElement | null;
  const submitButton = document.getElementById('submit-order-button') as HTMLButtonElement | null;
  const statusDiv = document.getElementById('order-status');
  // Implicit rendering adds a hidden input with this name
  const turnstileResponseInputName = 'cf-turnstile-response';

  if (form && nameInput && submitButton && statusDiv) {
    form.addEventListener('submit', async (event) => {
      event.preventDefault();

      const ordererName = nameInput.value.trim();

      if (!ordererName) {
        statusDiv.textContent = 'Please enter your name.';
        statusDiv.style.color = 'red';
        nameInput.focus();
        return;
      }

      // --- Get the Turnstile token ---
      const formData = new FormData(form);
      const turnstileToken = formData.get(turnstileResponseInputName)?.toString();

      if (!turnstileToken) {
        statusDiv.textContent = 'CAPTCHA challenge failed or is missing. Please wait or refresh.';
        statusDiv.style.color = 'red';
        // Optionally reset the widget if you have its ID, or just prompt user
        // turnstile.reset('#turnstile-widget-id'); // Requires explicit rendering or getting the ID
        return;
      }
      // --- End Get Turnstile token ---


      submitButton.disabled = true;
      submitButton.textContent = 'Processing...';
      statusDiv.textContent = 'Processing your request...';
      statusDiv.style.color = 'inherit';

      try {
        // 1. Ensure Authentication via Server Endpoint (from previous step)
        statusDiv.textContent = 'Ensuring session...';
        const authResponse = await fetch('/api/auth/anonymous', { method: 'POST' });

        if (!authResponse.ok) {
           const errorData = await authResponse.json().catch(() => ({}));
           console.error("Anonymous auth endpoint error:", authResponse.status, errorData);
           throw new Error(errorData.error || `Authentication setup failed: Status ${authResponse.status}`);
        }
        console.log("Session ensured via server endpoint.");

        // 2. Submit the order data (including Turnstile token)
        statusDiv.textContent = 'Submitting order...';

        const orderPayload = {
          orderer_name: ordererName,
          turnstileToken: turnstileToken // Include the token here
        };

        const orderResponse = await fetch('/api/orders/create', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'Accept': 'application/json',
          },
          body: JSON.stringify(orderPayload), // Send the payload including token
        });

        if (!orderResponse.ok) {
          let errorMsg = `HTTP error! Status: ${orderResponse.status}`;
          try {
            const errorData = await orderResponse.json();
            errorMsg = errorData.error || errorMsg;
          } catch (parseError) {}
          console.error("Order submission failed:", errorMsg);
          if (orderResponse.status === 401) {
            errorMsg = "Authorization failed. Please try refreshing the page.";
          } else if (orderResponse.status === 403) { // Handle Turnstile failure explicitly
             errorMsg = `CAPTCHA verification failed: ${errorMsg}. Please try again.`;
          }
          throw new Error(`Order submission failed: ${errorMsg}`);
        }

        const createdOrder = await orderResponse.json();
        console.log("Order created:", createdOrder);
        statusDiv.textContent = `Order submitted successfully! Order ID: ${createdOrder.id}`;
        statusDiv.style.color = 'green';
        form.reset();
        // Reset Turnstile widget after successful submission (optional but good practice)
        // Requires explicit rendering and storing widgetId, or targeting the element
        try {
          const widgetElement = form.querySelector('.cf-turnstile');
          if (widgetElement && (window as any).turnstile) {
             (window as any).turnstile.reset(widgetElement);
          }
        } catch(e) { console.warn("Could not reset Turnstile widget", e); }


      } catch (error: any) {
        console.error('Order process error:', error);
        statusDiv.textContent = `Error: ${error.message || 'An unexpected error occurred.'}`;
        statusDiv.style.color = 'red';
        // Optionally reset Turnstile here too on error
         try {
           const widgetElement = form.querySelector('.cf-turnstile');
           if (widgetElement && (window as any).turnstile) {
              (window as any).turnstile.reset(widgetElement);
           }
         } catch(e) { console.warn("Could not reset Turnstile widget on error", e); }

      } finally {
        submitButton.disabled = false;
        submitButton.textContent = 'Submit Order';
      }
    });
  } else {
    console.error('Could not find all required elements for the order form script.');
  }
</script>
```
---

`src/pages/signin.astro`:
```
---
// src/pages/signin.astro
import Layout from "../layout/Layout.astro";
const title = "Sign In";
---

<Layout title={title}>
  <main>
    <section>
      <h1>{title}</h1>
      <p>
        Use Google to sign in to your account.
      </p>
      <form
        action="/api/auth/signin"
        method="post"
      >
        <button
          value="google"
          name="provider"
          type="submit"
        >
           Sign in with Google
        </button>
      </form>
    </section>
  </main>
</Layout>
```
---

`src/pages/api/auth/anonymous.ts`:
```
// src/pages/api/auth/anonymous.ts
import type { APIRoute } from "astro";
import { supabase } from "../../../lib/supabase"; // Adjust path if needed
import { setAuthCookies } from '../../../utils/auth'; // <-- IMPORT ADDED

export const POST: APIRoute = async ({ cookies }) => { // Removed redirect as it's not used
  // Check if user already has a valid session cookie (optional but good practice)
  const existingAccessToken = cookies.get("sb-access-token");
  const existingRefreshToken = cookies.get("sb-refresh-token");

  if (existingAccessToken && existingRefreshToken) {
     // Optional: Validate existing session quickly?
     // For simplicity, if cookies exist, assume they might be valid or refreshable by middleware later.
     // You could add a supabase.auth.getUser(existingAccessToken.value) check here if strictness is needed.
     console.log("Anonymous sign-in skipped, existing session cookie found.");
     // Let's verify the existing token before skipping
     const { data: { user } } = await supabase.auth.getUser(existingAccessToken.value);
     if (user) {
        console.log("Existing anonymous session is valid.");
        return new Response(JSON.stringify({ message: "Already authenticated anonymously" }), { status: 200 });
     } else {
        console.log("Existing anonymous session token is invalid, proceeding with sign-in.");
     }
  }

  console.log("Attempting server-side anonymous sign-in...");
  // Perform anonymous sign-in on the server
  const { data, error } = await supabase.auth.signInAnonymously();

  if (error || !data?.session) {
    console.error("Server-side anonymous sign-in error:", error);
    return new Response(
      JSON.stringify({ error: error?.message || "Anonymous sign-in failed" }),
      { status: 500 }
    );
  }

  console.log("Server-side anonymous sign-in successful. Setting cookies.");

  // Set cookies using the utility function
  setAuthCookies(cookies, data.session); // <-- REPLACED manual cookies.set calls

  return new Response(
    JSON.stringify({ message: "Anonymous sign-in successful", userId: data.user?.id }), // Optionally return user ID
    { status: 200 }
  );
};
```
---

`src/pages/api/auth/callback.ts`:
```
import type { APIRoute } from "astro";
import { supabase } from "../../../lib/supabase";
import { setAuthCookies } from '../../../utils/auth';

export const GET: APIRoute = async ({ url, cookies, redirect }) => {
  const authCode = url.searchParams.get("code");

  if (!authCode) {
    return new Response("No code provided", { status: 400 });
  }

  const { data, error } = await supabase.auth.exchangeCodeForSession(authCode);

  if (error) {
    console.error("Auth Callback Error:", error.message);
    return new Response(error.message, { status: 500 });
  }

  if (!data.session) {
      console.error("Auth Callback Error: No session data returned after code exchange.");
      return new Response("Failed to establish session.", { status: 500});
  }

  setAuthCookies(cookies, data.session);

  return redirect("/dashboard");
};
```
---

`src/pages/api/auth/signin.ts`:
```
import type { APIRoute } from "astro";
import { supabase } from "../../../lib/supabase";
import type { Provider } from "@supabase/supabase-js";

const OAUTH_CALLBACK_PATH = "/api/auth/callback";

export const POST: APIRoute = async ({ request, cookies, redirect, url }) => {
  const formData = await request.formData();
  const provider = formData.get("provider")?.toString();

  const redirectUrl = `${url.origin}${OAUTH_CALLBACK_PATH}`;

  if (provider === "google") {
    const { data, error } = await supabase.auth.signInWithOAuth({
      provider: provider as Provider,
      options: {
        redirectTo: redirectUrl,
      },
    });

    if (error) {
      console.error("OAuth Error:", error.message);
      return new Response(error.message, { status: 500 });
    }

    return redirect(data.url);
  }
  return new Response("Invalid sign-in method", { status: 400 });
};
```
---

`src/pages/api/auth/signout.ts`:
```
import type { APIRoute } from "astro";

export const GET: APIRoute = async ({ cookies, redirect }) => {
  cookies.delete("sb-access-token", { path: "/" });
  cookies.delete("sb-refresh-token", { path: "/" });
  return redirect("/signin");
};

```
---

`src/pages/api/guestbook/index.ts`:
```
// src/pages/api/guestbook/index.ts
import type { APIRoute } from "astro";
// Import the SERVICE functions, NOT the supabase client directly for DB operations
import { getAllGuestbookEntries, createGuestbookEntry } from "../../../services/guestbook.service";
import type { GuestbookEntry } from "../../../types/types"; // Import type for request body validation

export const GET: APIRoute = async () => {
  console.log("API Route: GET /api/guestbook invoked.");
  try {
    // Call the service function to get data
    const entries = await getAllGuestbookEntries();

    // API route focuses on the HTTP response
    return new Response(JSON.stringify(entries), {
        status: 200,
        headers: { 'Content-Type': 'application/json' }
    });
  } catch (error: any) {
    console.error("API Error (GET /api/guestbook):", error.message);
    // Return a generic server error response (avoid leaking detailed errors)
    return new Response(
      JSON.stringify({ error: "Failed to retrieve guestbook entries." }),
      { status: 500, headers: { 'Content-Type': 'application/json' } }
    );
  }
};

export const POST: APIRoute = async ({ request }) => {
  console.log("API Route: POST /api/guestbook invoked.");
  try {
    // 1. Parse and validate request body at the API level
    let name: string;
    let message: string;
    try {
        // Ensure body is valid JSON and has the expected fields
        const body: Partial<GuestbookEntry> = await request.json();
        name = body.name?.toString() ?? ''; // Use nullish coalescing for safety
        message = body.message?.toString() ?? '';

        // Basic presence check (more specific validation is in the service)
        if (!name || !message) {
            console.log("API Error: Missing name or message in request body.");
            return new Response(JSON.stringify({ error: "Bad Request: Name and message are required."}), {
                 status: 400,
                 headers: { 'Content-Type': 'application/json' }
            });
        }
    } catch (e) {
        console.log("API Error: Invalid JSON body received.");
        return new Response(JSON.stringify({ error: "Bad Request: Invalid JSON body."}), {
            status: 400,
            headers: { 'Content-Type': 'application/json' }
        });
    }

    // 2. Call the service function to perform the action
    // The service handles its own validation and database logic
    const newEntry = await createGuestbookEntry(name, message);

    // 3. Return the successful HTTP response
    console.log("API Route: Guestbook entry created successfully.");
    return new Response(JSON.stringify(newEntry), {
        status: 201, // 201 Created is appropriate for successful POST
        headers: { 'Content-Type': 'application/json' }
    });

  } catch (error: any) {
    console.error("API Error (POST /api/guestbook):", error.message);

    // Handle specific errors thrown by the service
    if (error.message.startsWith("Validation Error:")) {
         return new Response( JSON.stringify({ error: `Bad Request: ${error.message}` }), {
            status: 400,
            headers: { 'Content-Type': 'application/json' }
         });
    }
    if (error.message.startsWith("Permission Denied:")) {
         return new Response( JSON.stringify({ error: error.message }), {
            status: 403, // Forbidden
            headers: { 'Content-Type': 'application/json' }
         });
    }
     if (error.message.startsWith("Database Error:")) {
         // Log the specific DB error but return a generic 500 to the client
         return new Response( JSON.stringify({ error: "Failed to submit guestbook entry due to a server error." }), {
            status: 500,
            headers: { 'Content-Type': 'application/json' }
         });
     }

    // Fallback for unexpected errors
    return new Response(
      JSON.stringify({ error: "An unexpected error occurred while submitting the guestbook entry." }),
      { status: 500, headers: { 'Content-Type': 'application/json' } }
    );
  }
};
```
---

`src/pages/api/orders/create.ts`:
```
// src/pages/api/orders/create.ts
import type { APIRoute } from "astro";
import { supabase } from "../../../lib/supabase"; // Keep for auth check ONLY
// Import the SERVICE function for database interaction
import { createOrder } from "../../../services/order.service";
import type { Order } from "../../../types/types"; // Import type if needed for request validation

// --- Turnstile Configuration ---
const TURNSTILE_VERIFY_ENDPOINT = 'https://challenges.cloudflare.com/turnstile/v0/siteverify';
const TURNSTILE_SECRET_KEY = import.meta.env.TURNSTILE_SECRET_KEY;
// --- End Turnstile ---

export const POST: APIRoute = async ({ request, cookies, clientAddress }) => {
  console.log("API Route: POST /api/orders/create invoked.");

  // --- Environment Variable Check ---
  if (!TURNSTILE_SECRET_KEY) {
      console.error("API Error: TURNSTILE_SECRET_KEY is not set.");
      return new Response(
          JSON.stringify({ error: "Server configuration error: CAPTCHA secret missing." }),
          { status: 500, headers: { 'Content-Type': 'application/json' } }
      );
  }

  // --- 1. Parse Request Body ---
  let ordererName: string | undefined;
  let turnstileToken: string | undefined;
  try {
    // Define expected body structure (optional but good practice)
    interface OrderRequestBody {
        orderer_name?: string;
        turnstileToken?: string;
    }
    const body: OrderRequestBody = await request.json();
    ordererName = body.orderer_name?.toString();
    turnstileToken = body.turnstileToken?.toString();

    if (!ordererName) {
        console.log("API Error: Missing orderer_name in request body.");
        return new Response(JSON.stringify({ error: "Bad Request: Orderer name is required." }), { status: 400, headers: { 'Content-Type': 'application/json' } });
    }
    if (!turnstileToken) {
        console.log("API Error: Missing turnstileToken in request body.");
        return new Response(JSON.stringify({ error: "Bad Request: CAPTCHA token is missing." }), { status: 400, headers: { 'Content-Type': 'application/json' } });
    }
  } catch (error) {
    console.log("API Error: Invalid JSON body received.");
    return new Response(JSON.stringify({ error: "Bad Request: Invalid JSON body." }), { status: 400, headers: { 'Content-Type': 'application/json' } });
  }

  // --- 2. Verify Turnstile Token ---
  try {
      console.log("API Route: Verifying Turnstile token...");
      const verifyPayload = new URLSearchParams();
      verifyPayload.append('secret', TURNSTILE_SECRET_KEY);
      verifyPayload.append('response', turnstileToken);

      const forwardedIp = request.headers.get('x-nf-client-connection-ip');
      const remoteIp = forwardedIp || clientAddress;
      if (remoteIp) {
          verifyPayload.append('remoteip', remoteIp);
          console.log("API Route: Verifying Turnstile with remoteip:", remoteIp);
      } else {
          console.warn("API Route: Verifying Turnstile without remoteip.");
      }

      const verifyResponse = await fetch(TURNSTILE_VERIFY_ENDPOINT, {
          method: 'POST',
          body: verifyPayload,
      });
      const verifyOutcome = await verifyResponse.json();
      console.log("API Route: Turnstile verification outcome:", verifyOutcome);

      if (!verifyOutcome.success) {
          console.warn("API Route: Turnstile verification failed.", verifyOutcome['error-codes']);
          return new Response(
              JSON.stringify({ error: "CAPTCHA verification failed.", codes: verifyOutcome['error-codes'] || [] }),
              { status: 403, headers: { 'Content-Type': 'application/json' } } // 403 Forbidden
          );
      }
      console.log("API Route: Turnstile verification successful for hostname:", verifyOutcome.hostname);

  } catch (error: any) {
      console.error("API Error: Exception during Turnstile verification:", error);
      return new Response(
          JSON.stringify({ error: "Server error during CAPTCHA verification." }),
          { status: 500, headers: { 'Content-Type': 'application/json' } }
      );
  }

  // --- 3. Verify Authentication (Get User ID) ---
  let userId: string;
  try {
      console.log("API Route: Verifying user authentication...");
      const accessToken = cookies.get("sb-access-token");
      if (!accessToken) {
          console.log("API Error: No access token found after CAPTCHA success.");
          // Middleware should ideally catch this, but double-check
          return new Response(JSON.stringify({ error: "Unauthorized: Authentication token missing." }), { status: 401, headers: { 'Content-Type': 'application/json' } });
      }

      // Use Supabase client *only* for auth check here
      const { data: { user }, error: userError } = await supabase.auth.getUser(accessToken.value);

      if (userError || !user) {
          console.error("API Error: Invalid session token after CAPTCHA.", userError?.message);
          // Consider attempting refresh here or instruct client to re-auth? For now, fail.
          // Clean up potentially invalid cookies?
          // cookies.delete("sb-access-token", { path: "/" });
          // cookies.delete("sb-refresh-token", { path: "/" });
          return new Response(JSON.stringify({ error: "Unauthorized: Invalid or expired session." }), { status: 401, headers: { 'Content-Type': 'application/json' } });
      }
      userId = user.id;
      console.log("API Route: User authenticated successfully:", userId);

  } catch (error: any) {
       console.error("API Error: Exception during authentication check:", error);
       return new Response( JSON.stringify({ error: "Server error during authentication check." }), { status: 500, headers: { 'Content-Type': 'application/json' } });
  }


  // --- 4. Call the Order Service ---
  try {
    console.log(`API Route: Calling createOrder service for user ${userId}`);
    // Pass necessary data (userId, ordererName) to the service
    const newOrder = await createOrder(userId, ordererName); // Service handles DB interaction

    // --- 5. Return Success Response ---
    console.log("API Route: Order created successfully:", newOrder.id);
    return new Response(JSON.stringify(newOrder), {
        status: 201, // Created
        headers: { 'Content-Type': 'application/json' }
     });

  } catch (error: any) {
    // --- 6. Handle Errors from Service ---
    console.error("API Error (POST /api/orders/create - Service Call):", error.message);

    // Map specific errors from the service to appropriate HTTP statuses
    if (error.message.startsWith("Validation Error:")) {
        return new Response( JSON.stringify({ error: `Bad Request: ${error.message}` }), {
             status: 400,
             headers: { 'Content-Type': 'application/json' }
        });
    }
    if (error.message.startsWith("Permission Denied:")) {
        return new Response( JSON.stringify({ error: error.message }), {
             status: 403, // Forbidden
             headers: { 'Content-Type': 'application/json' }
        });
    }
    if (error.message.startsWith("Database Error:")) {
         // Log the specific DB error but return a generic 500 to the client
         return new Response( JSON.stringify({ error: "Failed to create order due to a server database error." }), {
            status: 500,
            headers: { 'Content-Type': 'application/json' }
         });
    }

    // Generic fallback for unexpected errors during service call
    return new Response(
      JSON.stringify({ error: "An unexpected server error occurred while creating the order." }),
      { status: 500, headers: { 'Content-Type': 'application/json' } }
    );
  }
};
```
---

`src/services/guestbook.service.ts`:
```
// src/services/guestbook.service.ts
import { supabase } from '../lib/supabase'; // Import the initialized client
import type { GuestbookEntry } from '../types/types'; // Use our defined type

/**
 * Fetches all guestbook entries, ordered by creation date (ascending).
 * Throws an error if the Supabase query fails.
 */
export async function getAllGuestbookEntries(): Promise<GuestbookEntry[]> {
  console.log("Service: Fetching all guestbook entries...");
  const { data, error } = await supabase
    .from("guestbook")
    .select("name, message") // Select only needed fields defined in the type
    .order("created_at", { ascending: true }); // Or false based on desired display order

  if (error) {
    console.error("Service Error (getAllGuestbookEntries):", error);
    // Throw a new error to be caught by the calling API route
    throw new Error(`Failed to fetch guestbook entries: ${error.message}`);
  }

  console.log("Service: Fetched entries successfully.");
  // You might add more robust validation here depending on needs
  return data as GuestbookEntry[];
}

/**
 * Creates a new guestbook entry.
 * Throws an error if validation fails or the Supabase insert operation fails.
 * @param name - The name of the poster.
 * @param message - The message content.
 * @returns The newly created guestbook entry (only name and message).
 */
export async function createGuestbookEntry(name: string, message: string): Promise<GuestbookEntry> {
  // Basic validation within the service
  if (!name || !message || name.trim().length === 0 || message.trim().length === 0) {
      throw new Error("Validation Error: Name and message cannot be empty.");
  }

  const trimmedName = name.trim();
  const trimmedMessage = message.trim();

  console.log(`Service: Creating guestbook entry for '${trimmedName}'...`);
  const { data, error } = await supabase
    .from("guestbook")
    .insert({ name: trimmedName, message: trimmedMessage })
    .select("name, message") // Select the fields matching GuestbookEntry type
    .single(); // Expecting a single row back after insert

  if (error) {
    console.error("Service Error (createGuestbookEntry):", error);
    // Check for specific Supabase errors if needed (e.g., RLS violation '42501')
    if (error.code === '42501') {
        // Make error more specific for API layer to handle
        throw new Error("Permission Denied: Cannot create guestbook entry. Check RLS policies.");
    }
    // Generic database error
    throw new Error(`Database Error: Failed to create guestbook entry: ${error.message}`);
  }

  if (!data) {
      // This case should ideally not be reached if insert succeeded without error,
      // but acts as a safeguard.
      throw new Error("Database Error: Failed to create guestbook entry: No data returned after insert.");
  }

  console.log("Service: Created entry successfully.");
  return data as GuestbookEntry; // Return data matching the type
}
```
---

`src/services/order.service.ts`:
```
// src/services/order.service.ts
import { supabase } from '../lib/supabase';
import type { Order } from '../types/types'; // Import the Order type

/**
 * Creates a new order associated with a user ID.
 * Throws an error if validation fails or the Supabase insert operation fails.
 * @param userId - The authenticated user's ID (can be anonymous user ID).
 * @param ordererName - The name provided for the order.
 * @returns The newly created order data.
 */
export async function createOrder(userId: string, ordererName: string): Promise<Order> {
    // Basic validation
    if (!userId || !ordererName || ordererName.trim().length === 0) {
        throw new Error("Validation Error: User ID and a non-empty Orderer Name are required to create an order.");
    }

    const trimmedOrdererName = ordererName.trim();

    console.log(`Service: Creating order for user '${userId}' with name '${trimmedOrdererName}'...`);
    const { data, error } = await supabase
      .from("orders")
      .insert({
        user_id: userId,
        orderer_name: trimmedOrdererName,
        status: "pending", // Set default status
        // Add other default fields if necessary
      })
      .select() // Select all fields of the new order defined in the Order type
      .single(); // Expecting one row back

    if (error) {
      console.error("Service Error (createOrder):", error);
       if (error.code === '42501') {
         // Re-throw specific errors for better handling in the API layer
         throw new Error("Permission Denied: Cannot create order. Check RLS policies.");
       }
      // Generic database error
      throw new Error(`Database Error: Failed to create order: ${error.message}`);
    }

     if (!data) {
      // Safeguard against unexpected null data after successful insert
      throw new Error("Database Error: Failed to create order: No data returned after insert.");
     }

    console.log("Service: Created order successfully with ID:", data.id);
    // Cast to ensure the returned object matches the Order interface
    // Note: Supabase might return fields not explicitly in your type; casting narrows it.
    return data as Order;
}

// Potential future functions:
// export async function getOrderById(orderId: number): Promise<Order | null> { ... }
// export async function updateOrderStatus(orderId: number, status: Order['status']): Promise<Order> { ... }
// export async function getOrdersByUserId(userId: string): Promise<Order[]> { ... }
```
---

`src/types/types.ts`:
```
// src/types/types.ts

// Existing GuestbookEntry type
export interface GuestbookEntry {
  name: string;
  message: string;
  // Consider adding id and created_at if you fetch/use them
  // id?: number | string;
  // created_at?: string;
}

// New Order type (adjust fields based on your actual 'orders' table schema)
export interface Order {
  id: number; // Or string if you use UUIDs
  user_id: string; // Foreign key to auth.users
  orderer_name: string;
  status: "pending" | "processing" | "completed" | "cancelled"; // Example statuses
  created_at: string; // ISO timestamp string
  // Add any other relevant fields from your orders table
  // e.g., order_details: any;
  // e.g., total_price: number;
}
```
---

`src/utils/auth.ts`:
```
// src/utils/auth.ts
import type { Session } from '@supabase/supabase-js';
import type { AstroCookies } from 'astro';

/**
 * Sets the Supabase access and refresh token cookies with consistent security attributes.
 * @param cookies - The Astro cookies object from APIContext or MiddlewareAPIContext.
 * @param session - The Supabase session object containing tokens and expiration info.
 */
export function setAuthCookies(cookies: AstroCookies, session: Session | null | undefined): void {
  // Ensure we have a session and tokens before proceeding
  if (!session?.access_token || !session?.refresh_token) {
      console.warn("setAuthCookies called without a valid session or tokens. Skipping cookie setting.");
      // Optionally, clear existing cookies if session is null/undefined?
      // deleteAuthCookies(cookies); // Be cautious if calling this here
      return;
  }

  const { access_token, refresh_token, expires_in } = session;

  const baseCookieOptions = {
    path: "/",
    sameSite: "lax" as const,
    secure: import.meta.env.PROD,
    httpOnly: true,
  };

  // Calculate Access Token maxAge: Use expires_in (if valid > 0), default 1 hour.
  // MUST be an integer, so use Math.floor().
  const rawAccessTokenMaxAge = (expires_in != null && expires_in > 0) ? expires_in : 3600;
  const accessTokenMaxAge = Math.floor(rawAccessTokenMaxAge); // <-- THE FIX

  // Define Refresh Token maxAge: Typically longer, e.g., 7 days (already an integer)
  const refreshTokenMaxAge = 60 * 60 * 24 * 7; // 7 days in seconds

  // Add a check/log if the calculated maxAge seems wrong
  if (accessTokenMaxAge <= 0) {
      console.warn(`Calculated accessTokenMaxAge is invalid (${accessTokenMaxAge}). Using default 3600.`);
      // accessTokenMaxAge = 3600; // Re-assign default if needed, though floor(>0) should be >= 0
  }

  console.log(`Setting auth cookies. Access token maxAge: ${accessTokenMaxAge}s`);

  cookies.set("sb-access-token", access_token, {
    ...baseCookieOptions,
    maxAge: accessTokenMaxAge, // Pass the floored integer value
  });

  cookies.set("sb-refresh-token", refresh_token, {
    ...baseCookieOptions,
    maxAge: refreshTokenMaxAge,
  });
}

/**
 * Deletes the Supabase authentication cookies.
 * @param cookies - The Astro cookies object.
 */
export function deleteAuthCookies(cookies: AstroCookies): void {
    console.log("Deleting auth cookies.");
    cookies.delete("sb-access-token", { path: "/" });
    cookies.delete("sb-refresh-token", { path: "/" });
}
```
---
