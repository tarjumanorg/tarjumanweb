---

`astro.config.mjs`:
```
import { defineConfig } from 'astro/config';
import netlify from '@astrojs/netlify';

export default defineConfig({
  site: 'https://tarjuman.netlify.app',
  output: 'server',
  adapter: netlify(),

});
```
---

`tsconfig.json`:
```
{
  "extends": "astro/tsconfigs/strict",
  "include": [".astro/types.d.ts", "**/*"],
  "exclude": ["dist"]
}

```
---

`src/env.d.ts`:
```
declare namespace App {
  interface Locals {
    email: string;
  }
}
```
---

`src/components/Reviews.astro`:
```
---
// src/components/Reviews.astro
import type { GuestbookEntry } from "../types/types";

interface Props {
  reviews: GuestbookEntry[];
}

const { reviews } = Astro.props;
---

<div>
  <form
    id="guestbook-form"
    method="post"
    action="/api/guestbook"
  >
    <h3 >Leave a message</h3>


    <div id="form-status"></div>

    <div >
      <label
        for="name"
      >
        Name
      </label>
      <input
        id="name"
        type="text"
        placeholder="Your Name"
        required
        name="name"
            />
    </div>
    <div >
      <label
        for="message"
              >
        Message
      </label>

      <input
        id="message"
        type="text"
        placeholder="A friendly message..."
        required
        name="message"
           />
    </div>
    <button
      id="submit-button"
      type="submit"
        >
      Submit
    </button>
  </form>

  <h3>Guestbook Entries</h3>
   <div id="reviews-list">
    {reviews.length > 0 ? (
        <ul>
        {reviews.map((review) => (
            <li>
            <p>
              
                {review.name}

            </p>
            <p>{review.message}</p>
            </li>
        ))}
        </ul>
    ) : (
        <p>No reviews yet. Be the first!</p>
    )}
   </div>
</div>

<script>
  const form = document.getElementById('guestbook-form') as HTMLFormElement;
  const nameInput = document.getElementById('name') as HTMLInputElement;
  const messageInput = document.getElementById('message') as HTMLInputElement;
  const statusDiv = document.getElementById('form-status');
  const submitButton = document.getElementById('submit-button') as HTMLButtonElement;

  if (form && nameInput && messageInput && statusDiv && submitButton) {
    form.addEventListener('submit', async (event) => {
      event.preventDefault();

      statusDiv.textContent = '';
      submitButton.disabled = true;
      submitButton.textContent = 'Submitting...';

      const name = nameInput.value;
      const message = messageInput.value;

      const payload = JSON.stringify({ name, message });

      try {
        const response = await fetch(form.action, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'Accept': 'application/json',
          },
          body: payload,
        });


        const data = await response.json(); 

        if (!response.ok) {
          throw new Error(data.error || `HTTP error! Status: ${response.status}`);
        }

        statusDiv.textContent = 'Message submitted successfully!';
        form.reset();

      } catch (error: any) {
        console.error('Submission error:', error);
        statusDiv.textContent = `Error: ${error.message || 'Could not submit message.'}`;

      } finally {
        submitButton.disabled = false;
        submitButton.textContent = 'Submit';
      }
    });
  } else {
    console.error('Could not find all required form elements for guestbook submission script.');
  }
</script>
```
---

`src/layout/Layout.astro`:
```
---
interface Props {
  title: string;
}

const description = "Astro and Supabase demo app";
const { title } = Astro.props;
const ogImageURL = new URL("hero.png", Astro.site).href;
const canonicalURL = new URL(Astro.url).href;
---

<html lang="en">
  <head>
    <title>{title}</title>
    <meta charset="utf-8" />
    <link rel="icon" type="image/svg+xml" href="/favicon.svg" />
    <meta name="viewport" content="width=device-width" />
    <meta name="generator" content={Astro.generator} />
    <meta name="description" content={description} />
    <meta property="twitter:image" content={ogImageURL} />
    <meta property="twitter:card" content="summary_large_image" />
    <meta property="twitter:title" content={title} />
    <meta property="twitter:description" content={description} />
    <meta property="og:image" content={ogImageURL} />
    <meta property="og:title" content={title} />
    <meta property="og:description" content={description} />
    <meta property="og:url" content={canonicalURL} />
  </head>
  <body>
    <nav>
      <div>
        <a href="/">Astro</a>
        <div>
          <ul>
            <li>
              <a href="/dashboard">Dashboard</a>
            </li>
            <li>
              <a href="/signin">Sign in</a>
            </li>
          </ul>
        </div>
      </div>
    </nav>
    <slot />
  </body>
</html>
```
---

`src/lib/supabase.ts`:
```
// src/lib/supabase.ts
import { createClient } from "@supabase/supabase-js";

const supabaseUrl = import.meta.env.PUBLIC_SUPABASE_URL;
const supabaseAnonKey = import.meta.env.PUBLIC_SUPABASE_ANON_KEY;

if (!supabaseUrl || !supabaseAnonKey) {
  throw new Error("Supabase URL or Anon Key is missing.");
}

export const supabase = createClient(
  supabaseUrl,
  supabaseAnonKey,
  {
    auth: {
      flowType: "pkce",
      autoRefreshToken: true,
      detectSessionInUrl: false,
      persistSession: true,
    },
  },
);
```
---

`src/middleware/index.ts`:
```
// src/middleware/index.ts
import { defineMiddleware } from "astro:middleware";
import { supabase } from "../lib/supabase";

// Define routes clearly
const protectedPaths = ["/dashboard"];
const redirectPaths = ["/signin", "/register"]; // Assuming you might add /register later
// Add the new API route for creating orders
const protectedAPIPaths = ["/api/guestbook", "/api/orders/create"]; // <-- ADDED HERE

// Helper function to check paths, handling optional trailing slash
function matchesPath(pathname: string, pathsToCheck: string[]): boolean {
  const normalizedPathname = pathname.endsWith('/') && pathname.length > 1
    ? pathname.slice(0, -1)
    : pathname;
  return pathsToCheck.includes(normalizedPathname);
}

export const onRequest = defineMiddleware(
  async ({ locals, url, cookies, redirect }, next) => {

    const isProtectedRoute = matchesPath(url.pathname, protectedPaths);

    if (isProtectedRoute) {
      const accessToken = cookies.get("sb-access-token");
      const refreshToken = cookies.get("sb-refresh-token");

      if (!accessToken || !refreshToken) {
        return redirect("/signin");
      }

      const { data, error } = await supabase.auth.setSession({
        refresh_token: refreshToken.value,
        access_token: accessToken.value,
      });

      if (error) {
        cookies.delete("sb-access-token", { path: "/" });
        cookies.delete("sb-refresh-token", { path: "/" });
        return redirect("/signin");
      }

      // Store email in locals for dashboard page
      locals.email = data.user?.email!;

      // Refresh cookies with potentially new tokens and ensure flags are set
      cookies.set("sb-access-token", data?.session?.access_token!, {
        sameSite: "strict",
        path: "/",
        secure: import.meta.env.PROD, // Use secure cookies in production
        httpOnly: true
      });
      cookies.set("sb-refresh-token", data?.session?.refresh_token!, {
        sameSite: "strict",
        path: "/",
        secure: import.meta.env.PROD, // Use secure cookies in production
        httpOnly: true,
      });
    }

    const isRedirectRoute = matchesPath(url.pathname, redirectPaths);

    if (isRedirectRoute) {
      const accessToken = cookies.get("sb-access-token");
      const refreshToken = cookies.get("sb-refresh-token");

      if (accessToken && refreshToken) {
        // Optional: Quick validation before redirecting?
        // For simplicity, just redirect if tokens exist.
        // A robust check might involve supabase.auth.getUser(accessToken.value)
        return redirect("/dashboard");
      }
    }

    const isProtectedAPIRoute = matchesPath(url.pathname, protectedAPIPaths);

    if (isProtectedAPIRoute) {
      const accessToken = cookies.get("sb-access-token");
      const refreshToken = cookies.get("sb-refresh-token"); // Keep refresh token check for robustness

      if (!accessToken) { // Primarily check access token for API calls
         console.log("Middleware: No access token for protected API route");
         return new Response(JSON.stringify({ error: "Unauthorized: Missing token" }), { status: 401 });
      }

      // Validate the access token
      const { data: { user }, error } = await supabase.auth.getUser(accessToken.value);

      if (error || !user) {
        console.log("Middleware: Invalid/Expired token for API route.", error?.message);
        // Attempt refresh only if refresh token exists (though less common for API calls)
        if (refreshToken) {
           const { data: refreshData , error: refreshError } = await supabase.auth.setSession({
                refresh_token: refreshToken.value,
                access_token: accessToken.value, // Include access token for potential validation
           });

            if (refreshError || !refreshData.session) {
                console.log("Middleware: Session refresh failed for API route.");
                cookies.delete("sb-access-token", { path: "/" });
                cookies.delete("sb-refresh-token", { path: "/" });
                return new Response(JSON.stringify({ error: "Unauthorized: Session Refresh Failed" }), { status: 401 });
            }

             // If refresh worked, set new cookies (important!) and proceed
             console.log("Middleware: Session refreshed successfully for API route.");
             cookies.set("sb-access-token", refreshData.session.access_token, {
               sameSite: "strict", path: "/", secure: import.meta.env.PROD, httpOnly: true
             });
             cookies.set("sb-refresh-token", refreshData.session.refresh_token, {
               sameSite: "strict", path: "/", secure: import.meta.env.PROD, httpOnly: true
             });
             // We *could* store the user ID in locals here if needed by multiple API endpoints
             // locals.userId = refreshData.user.id;
             return next(); // Proceed with the refreshed session
        } else {
            // No refresh token, definitely unauthorized
            cookies.delete("sb-access-token", { path: "/" }); // Clean up invalid token
            return new Response(JSON.stringify({ error: "Unauthorized: Invalid Token" }), { status: 401 });
        }
      }
      // If token is valid, proceed.
      // We *could* store the user ID in locals here if needed by multiple API endpoints
      // locals.userId = user.id;
    }

    // If none of the above conditions were met, proceed to the route handler
    return next();
  },
);
```
---

`src/pages/dashboard.astro`:
```
---
// src/pages/dashboard.astro
import Layout from "../layout/Layout.astro";
import { supabase } from "../lib/supabase";
import Reviews from "../components/Reviews.astro";
import type { GuestbookEntry } from "../types/types";

const { email } = Astro.locals;

let reviews: GuestbookEntry[] = [];
let fetchError: string | null = null;

try {
  const { data, error } = await supabase
    .from("guestbook")
    .select("name, message")
    .order("created_at", { ascending: false });

  if (error) {
    throw error;
  }
  reviews = data as GuestbookEntry[];

} catch (e: any) {
   fetchError = `Failed to load reviews: ${e.message}`;
   console.error("Error fetching reviews:", e);
}
---

<Layout title="Dashboard">
  <section>
    <p>
      Logged in as: <strong>{email}</strong>
    </p>
    <p>
      This is a protected page. You can only see this if you are logged in.
    </p>
    <a
      href="/api/auth/signout"
      >Sign out</a
    >

    {fetchError && <p>{fetchError}</p>}

    <Reviews reviews={reviews} />
  </section>
</Layout>
```
---

`src/pages/index.astro`:
```
---
import Layout from "../layout/Layout.astro";
export const prerender = true;
const title = "Supabase and Astro Demo";
---

<Layout title={title}>
  <main>
    <h1>{title}</h1>
    <ul>
      <li
      >
      </li>
       &plus;
      <li
      >
      </li>
    </ul>
    <p>This page was pre-rendered at build time</p>
  </main>
</Layout>

```
---

`src/pages/order.astro`:
```
---
// src/pages/order.astro
import Layout from "../layout/Layout.astro";

const title = "Place Your Order";
// Your Turnstile Site Key (safe to be public)
const turnstileSiteKey = "0x4AAAAAABDz77Fkj-zw6ls4";
---

<Layout title={title}>
  <head>
    <!-- Add Turnstile script in the head -->
    <script src="https://challenges.cloudflare.com/turnstile/v0/api.js" defer></script>
  </head>
  <main>
    <section>
      <h1>{title}</h1>
      <p>Enter your name to start your order.</p>

      <form id="order-form">
        <div>
          <label for="orderer-name">Your Name:</label>
          <input
            type="text"
            id="orderer-name"
            name="orderer_name"
            required
            placeholder="Enter your name"
          />
        </div>

        <!-- Add the Turnstile Widget Div here -->
        <div
          class="cf-turnstile"
          data-sitekey={turnstileSiteKey}
          style="margin-top: 1rem;"
        >
        </div>
        <!-- End Turnstile Widget Div -->

        <div id="order-status" aria-live="polite" style="margin-top: 1rem; min-height: 1.5em;">
          {/* Status messages will appear here */}
        </div>

        <button type="submit" id="submit-order-button" style="margin-top: 1rem;">
          Submit Order
        </button>
      </form>

    </section>
  </main>
</Layout>

<script>
  // No changes needed for supabase import if you keep the server-side anonymous auth
  // import { supabase } from '../lib/supabase';

  const form = document.getElementById('order-form') as HTMLFormElement | null;
  const nameInput = document.getElementById('orderer-name') as HTMLInputElement | null;
  const submitButton = document.getElementById('submit-order-button') as HTMLButtonElement | null;
  const statusDiv = document.getElementById('order-status');
  // Implicit rendering adds a hidden input with this name
  const turnstileResponseInputName = 'cf-turnstile-response';

  if (form && nameInput && submitButton && statusDiv) {
    form.addEventListener('submit', async (event) => {
      event.preventDefault();

      const ordererName = nameInput.value.trim();

      if (!ordererName) {
        statusDiv.textContent = 'Please enter your name.';
        statusDiv.style.color = 'red';
        nameInput.focus();
        return;
      }

      // --- Get the Turnstile token ---
      const formData = new FormData(form);
      const turnstileToken = formData.get(turnstileResponseInputName)?.toString();

      if (!turnstileToken) {
        statusDiv.textContent = 'CAPTCHA challenge failed or is missing. Please wait or refresh.';
        statusDiv.style.color = 'red';
        // Optionally reset the widget if you have its ID, or just prompt user
        // turnstile.reset('#turnstile-widget-id'); // Requires explicit rendering or getting the ID
        return;
      }
      // --- End Get Turnstile token ---


      submitButton.disabled = true;
      submitButton.textContent = 'Processing...';
      statusDiv.textContent = 'Processing your request...';
      statusDiv.style.color = 'inherit';

      try {
        // 1. Ensure Authentication via Server Endpoint (from previous step)
        statusDiv.textContent = 'Ensuring session...';
        const authResponse = await fetch('/api/auth/anonymous', { method: 'POST' });

        if (!authResponse.ok) {
           const errorData = await authResponse.json().catch(() => ({}));
           console.error("Anonymous auth endpoint error:", authResponse.status, errorData);
           throw new Error(errorData.error || `Authentication setup failed: Status ${authResponse.status}`);
        }
        console.log("Session ensured via server endpoint.");

        // 2. Submit the order data (including Turnstile token)
        statusDiv.textContent = 'Submitting order...';

        const orderPayload = {
          orderer_name: ordererName,
          turnstileToken: turnstileToken // Include the token here
        };

        const orderResponse = await fetch('/api/orders/create', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'Accept': 'application/json',
          },
          body: JSON.stringify(orderPayload), // Send the payload including token
        });

        if (!orderResponse.ok) {
          let errorMsg = `HTTP error! Status: ${orderResponse.status}`;
          try {
            const errorData = await orderResponse.json();
            errorMsg = errorData.error || errorMsg;
          } catch (parseError) {}
          console.error("Order submission failed:", errorMsg);
          if (orderResponse.status === 401) {
            errorMsg = "Authorization failed. Please try refreshing the page.";
          } else if (orderResponse.status === 403) { // Handle Turnstile failure explicitly
             errorMsg = `CAPTCHA verification failed: ${errorMsg}. Please try again.`;
          }
          throw new Error(`Order submission failed: ${errorMsg}`);
        }

        const createdOrder = await orderResponse.json();
        console.log("Order created:", createdOrder);
        statusDiv.textContent = `Order submitted successfully! Order ID: ${createdOrder.id}`;
        statusDiv.style.color = 'green';
        form.reset();
        // Reset Turnstile widget after successful submission (optional but good practice)
        // Requires explicit rendering and storing widgetId, or targeting the element
        try {
          const widgetElement = form.querySelector('.cf-turnstile');
          if (widgetElement && (window as any).turnstile) {
             (window as any).turnstile.reset(widgetElement);
          }
        } catch(e) { console.warn("Could not reset Turnstile widget", e); }


      } catch (error: any) {
        console.error('Order process error:', error);
        statusDiv.textContent = `Error: ${error.message || 'An unexpected error occurred.'}`;
        statusDiv.style.color = 'red';
        // Optionally reset Turnstile here too on error
         try {
           const widgetElement = form.querySelector('.cf-turnstile');
           if (widgetElement && (window as any).turnstile) {
              (window as any).turnstile.reset(widgetElement);
           }
         } catch(e) { console.warn("Could not reset Turnstile widget on error", e); }

      } finally {
        submitButton.disabled = false;
        submitButton.textContent = 'Submit Order';
      }
    });
  } else {
    console.error('Could not find all required elements for the order form script.');
  }
</script>
```
---

`src/pages/signin.astro`:
```
---
// src/pages/signin.astro
import Layout from "../layout/Layout.astro";
const title = "Sign In";
---

<Layout title={title}>
  <main>
    <section>
      <h1>{title}</h1>
      <p>
        Use Google to sign in to your account.
      </p>
      <form
        action="/api/auth/signin"
        method="post"
      >
        <button
          value="google"
          name="provider"
          type="submit"
        >
           Sign in with Google
        </button>
      </form>
    </section>
  </main>
</Layout>
```
---

`src/pages/api/guestbook.ts`:
```
import type { APIRoute } from "astro";
import { supabase } from "../../lib/supabase";

export const GET: APIRoute = async () => {
  const { data, error } = await supabase
    .from("guestbook")
    .select("*")
    .order("created_at", { ascending: true });

  if (error) {
    return new Response(
      JSON.stringify({
        error: error.message,
      }),
      { status: 500 },
    );
  }
  
  return new Response(JSON.stringify(data));
};

export const POST: APIRoute = async ({ request }) => {
  const { name, message } = await request.json();
  const { data, error } = await supabase
    .from("guestbook")
    .insert({ name, message })
    .select();

  if (error) {
    return new Response(
      JSON.stringify({
        error: error.message,
      }),
      { status: 500 },
    );
  }

  return new Response(JSON.stringify(data));
};

```
---

`src/pages/api/auth/anonymous.ts`:
```
// src/pages/api/auth/anonymous.ts
import type { APIRoute } from "astro";
import { supabase } from "../../../lib/supabase"; // Adjust path if needed

export const POST: APIRoute = async ({ cookies, redirect }) => {
  // Check if user already has a valid session cookie (optional but good practice)
  const existingAccessToken = cookies.get("sb-access-token");
  const existingRefreshToken = cookies.get("sb-refresh-token");

  if (existingAccessToken && existingRefreshToken) {
     // Optional: Validate existing session quickly?
     // For simplicity, if cookies exist, assume they might be valid or refreshable by middleware later.
     // You could add a supabase.auth.getUser(existingAccessToken.value) check here if strictness is needed.
     console.log("Anonymous sign-in skipped, existing session cookie found.");
     return new Response(JSON.stringify({ message: "Already authenticated" }), { status: 200 });
  }

  console.log("Attempting server-side anonymous sign-in...");
  // Perform anonymous sign-in on the server
  const { data, error } = await supabase.auth.signInAnonymously();

  if (error || !data?.session) {
    console.error("Server-side anonymous sign-in error:", error);
    return new Response(
      JSON.stringify({ error: error?.message || "Anonymous sign-in failed" }),
      { status: 500 }
    );
  }

  console.log("Server-side anonymous sign-in successful. Setting cookies.");
  const { access_token, refresh_token } = data.session;

  // Set the HttpOnly cookies, mirroring the /api/auth/callback logic
  cookies.set("sb-access-token", access_token, {
    path: "/",
    maxAge: data.session.expires_in ? data.session.expires_in : 60 * 60, // Use expires_in, default 1 hour
    sameSite: "strict",
    secure: import.meta.env.PROD, // Use secure cookies in production
    httpOnly: true,
  });
  cookies.set("sb-refresh-token", refresh_token, {
    path: "/",
    maxAge: 60 * 60 * 24 * 7, // Example: 7 days validity for refresh token
    sameSite: "strict",
    secure: import.meta.env.PROD, // Use secure cookies in production
    httpOnly: true,
  });

  // Return a success response to the client
  return new Response(
    JSON.stringify({ message: "Anonymous sign-in successful", userId: data.user?.id }), // Optionally return user ID
    { status: 200 }
  );
};
```
---

`src/pages/api/auth/callback.ts`:
```
import type { APIRoute } from "astro";
import { supabase } from "../../../lib/supabase";

export const GET: APIRoute = async ({ url, cookies, redirect }) => {
  const authCode = url.searchParams.get("code");

  if (!authCode) {
    return new Response("No code provided", { status: 400 });
  }

  const { data, error } = await supabase.auth.exchangeCodeForSession(authCode);

  if (error) {
    return new Response(error.message, { status: 500 });
  }

  const { access_token, refresh_token } = data.session;

  cookies.set("sb-access-token", access_token, {
    path: "/",
    secure: true,
    httpOnly: true,
  });
  cookies.set("sb-refresh-token", refresh_token, {
    path: "/",
    secure: true,
    httpOnly: true,
  });
  return redirect("/dashboard");
};

```
---

`src/pages/api/auth/signin.ts`:
```
import type { APIRoute } from "astro";
import { supabase } from "../../../lib/supabase";
import type { Provider } from "@supabase/supabase-js";

const OAUTH_CALLBACK_PATH = "/api/auth/callback";

export const POST: APIRoute = async ({ request, cookies, redirect, url }) => {
  const formData = await request.formData();
  const provider = formData.get("provider")?.toString();

  const redirectUrl = `${url.origin}${OAUTH_CALLBACK_PATH}`;

  if (provider === "google") {
    const { data, error } = await supabase.auth.signInWithOAuth({
      provider: provider as Provider,
      options: {
        redirectTo: redirectUrl,
      },
    });

    if (error) {
      console.error("OAuth Error:", error.message);
      return new Response(error.message, { status: 500 });
    }

    return redirect(data.url);
  }
  return new Response("Invalid sign-in method", { status: 400 });
};
```
---

`src/pages/api/auth/signout.ts`:
```
import type { APIRoute } from "astro";

export const GET: APIRoute = async ({ cookies, redirect }) => {
  cookies.delete("sb-access-token", { path: "/" });
  cookies.delete("sb-refresh-token", { path: "/" });
  return redirect("/signin");
};

```
---

`src/pages/api/orders/create.ts`:
```
// src/pages/api/orders/create.ts
import type { APIRoute } from "astro";
import { supabase } from "../../../lib/supabase";

// --- Turnstile Siteverify Endpoint ---
const TURNSTILE_VERIFY_ENDPOINT = 'https://challenges.cloudflare.com/turnstile/v0/siteverify';
const TURNSTILE_SECRET_KEY = import.meta.env.TURNSTILE_SECRET_KEY;
// --- End Turnstile ---


export const POST: APIRoute = async ({ request, cookies, clientAddress }) => { // Added clientAddress

  if (!TURNSTILE_SECRET_KEY) {
      console.error("API /api/orders/create: TURNSTILE_SECRET_KEY is not set in environment variables.");
      return new Response(
          JSON.stringify({ error: "Server configuration error: Missing CAPTCHA secret." }),
          { status: 500 }
      );
  }

  // 1. Get submitted data (including Turnstile token)
  let ordererName: string | undefined;
  let turnstileToken: string | undefined;
  try {
    const data = await request.json();
    ordererName = data.orderer_name?.toString().trim();
    turnstileToken = data.turnstileToken?.toString(); // Get the token from payload

    if (!ordererName) {
      return new Response(
        JSON.stringify({ error: "Orderer name is required." }),
        { status: 400 }
      );
    }
    if (!turnstileToken) {
      return new Response(
        JSON.stringify({ error: "CAPTCHA token is missing." }),
        { status: 400 }
      );
    }
  } catch (error) {
    return new Response(
      JSON.stringify({ error: "Invalid request body. Expected JSON." }),
      { status: 400 }
    );
  }

  // --- 2. Verify Turnstile Token ---
  try {
      const verifyPayload = new URLSearchParams(); // Use URLSearchParams for form-encoded data
      verifyPayload.append('secret', TURNSTILE_SECRET_KEY);
      verifyPayload.append('response', turnstileToken);
      // Optionally add remoteip - Recommended for extra security
      // Astro's clientAddress gives the direct connecting IP, which might be Netlify's proxy.
      // If using Netlify, check request headers like 'x-nf-client-connection-ip'
      const forwardedIp = request.headers.get('x-nf-client-connection-ip');
      const remoteIp = forwardedIp || clientAddress; // Use forwarded IP if available, else direct clientAddress
      if (remoteIp) {
          verifyPayload.append('remoteip', remoteIp);
          console.log("Verifying Turnstile with remoteip:", remoteIp);
      } else {
          console.log("Verifying Turnstile without remoteip.");
      }


      const verifyResponse = await fetch(TURNSTILE_VERIFY_ENDPOINT, {
          method: 'POST',
          body: verifyPayload, // Send as form data
          headers: {
              // 'Content-Type': 'application/x-www-form-urlencoded' // fetch sets this automatically for URLSearchParams
          }
      });

      const verifyOutcome = await verifyResponse.json();

      console.log("Turnstile verification outcome:", verifyOutcome);

      if (!verifyOutcome.success) {
          console.warn("API /api/orders/create: Turnstile verification failed.", verifyOutcome['error-codes']);
          return new Response(
              JSON.stringify({
                  error: "CAPTCHA verification failed.",
                  codes: verifyOutcome['error-codes'] || []
              }),
              { status: 403 } // 403 Forbidden is appropriate for failed CAPTCHA
          );
      }
      // Turnstile validation passed! Proceed...
      console.log("Turnstile verification successful for hostname:", verifyOutcome.hostname);

  } catch (error: any) {
      console.error("API /api/orders/create: Error during Turnstile verification", error);
      return new Response(
          JSON.stringify({ error: "Failed to verify CAPTCHA." }),
          { status: 500 }
      );
  }
  // --- End Turnstile Verification ---


  // 3. Verify authentication and get user ID (Middleware should have run)
  const accessToken = cookies.get("sb-access-token");

  if (!accessToken) {
    // This check might be redundant if the anonymous auth endpoint always runs first,
    // but good for robustness if someone calls the API directly without going through the page flow.
    return new Response(JSON.stringify({ error: "Unauthorized: Missing token after CAPTCHA" }), { status: 401 });
  }

  const { data: { user }, error: userError } = await supabase.auth.getUser(accessToken.value);

  if (userError || !user) {
    console.error("API /api/orders/create: Error getting user after CAPTCHA", userError);
    return new Response(JSON.stringify({ error: "Unauthorized: Invalid session after CAPTCHA" }), { status: 401 });
  }

  const userId = user.id;

  // 4. Insert into Database
  try {
    const { data: newOrder, error: insertError } = await supabase
      .from("orders")
      .insert({
        user_id: userId,
        orderer_name: ordererName,
        status: "pending",
        // other fields...
      })
      .select()
      .single();

    if (insertError) {
      console.error("API /api/orders/create: Supabase insert error", insertError);
      if (insertError.code === '42501') {
         return new Response(
            JSON.stringify({ error: "Database permission denied. Check RLS policies." }),
            { status: 403 }
         );
      }
      return new Response(
        JSON.stringify({ error: "Database error: " + insertError.message }),
        { status: 500 }
      );
    }

    // 5. Return Success Response
    return new Response(JSON.stringify(newOrder), { status: 201 });

  } catch (error: any) {
    console.error("API /api/orders/create: Unexpected error during DB insert", error);
    return new Response(
      JSON.stringify({ error: "An unexpected error occurred." }),
      { status: 500 }
    );
  }
};
```
---

`src/types/types.ts`:
```
// src/types/types.ts
export interface GuestbookEntry {
    name: string;
    message: string;
  }
```
---
