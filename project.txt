---

`.env`:
```
PUBLIC_SUPABASE_URL=https://blopbebmckbgyrpzisjt.supabase.co
PUBLIC_SUPABASE_ANON_KEY=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImJsb3BiZWJtY2tiZ3lycHppc2p0Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3NDM0NzA5NDUsImV4cCI6MjA1OTA0Njk0NX0.4p-Q-k9oX5wEBy7tq57SFgjbw99WdNGjiBW3pE-RACI

PUBLIC_TURNSTILE_SITE_KEY="0x4AAAAAABDz77Fkj-zw6ls4" # Publicly visible
TURNSTILE_SECRET_KEY="0x4AAAAAABDz75OOEBihJZB-ORudV6xSR4E"
```

---

`astro.config.mjs`:
```
import { defineConfig } from 'astro/config';
import netlify from '@astrojs/netlify';

export default defineConfig({
  site: 'https://tarjuman.netlify.app',
  output: 'server',
  adapter: netlify(),

});
```
---

`tsconfig.json`:
```
{
  "extends": "astro/tsconfigs/strict",
  "include": [".astro/types.d.ts", "**/*"],
  "exclude": ["dist"]
}

```
---

`src/env.d.ts`:
```
declare namespace App {
  interface Locals {
    email: string;
  }
}
```
---

`src/components/Reviews.astro`:
```
---
// src/components/Reviews.astro
import type { GuestbookEntry } from "../types/types";

interface Props {
  reviews: GuestbookEntry[];
}

const { reviews } = Astro.props;
---

<div>
  <form
    id="guestbook-form"
    method="post"
    action="/api/guestbook"
  >
    <h3 >Leave a message</h3>


    <div id="form-status"></div>

    <div >
      <label
        for="name"
      >
        Name
      </label>
      <input
        id="name"
        type="text"
        placeholder="Your Name"
        required
        name="name"
            />
    </div>
    <div >
      <label
        for="message"
              >
        Message
      </label>

      <input
        id="message"
        type="text"
        placeholder="A friendly message..."
        required
        name="message"
           />
    </div>
    <button
      id="submit-button"
      type="submit"
        >
      Submit
    </button>
  </form>

  <h3>Guestbook Entries</h3>
   <div id="reviews-list">
    {reviews.length > 0 ? (
        <ul>
        {reviews.map((review) => (
            <li>
            <p>
              
                {review.name}

            </p>
            <p>{review.message}</p>
            </li>
        ))}
        </ul>
    ) : (
        <p>No reviews yet. Be the first!</p>
    )}
   </div>
</div>

<script>
  const form = document.getElementById('guestbook-form') as HTMLFormElement;
  const nameInput = document.getElementById('name') as HTMLInputElement;
  const messageInput = document.getElementById('message') as HTMLInputElement;
  const statusDiv = document.getElementById('form-status');
  const submitButton = document.getElementById('submit-button') as HTMLButtonElement;

  if (form && nameInput && messageInput && statusDiv && submitButton) {
    form.addEventListener('submit', async (event) => {
      event.preventDefault();

      statusDiv.textContent = '';
      submitButton.disabled = true;
      submitButton.textContent = 'Submitting...';

      const name = nameInput.value;
      const message = messageInput.value;

      const payload = JSON.stringify({ name, message });

      try {
        const response = await fetch(form.action, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'Accept': 'application/json',
          },
          body: payload,
        });


        const data = await response.json(); 

        if (!response.ok) {
          throw new Error(data.error || `HTTP error! Status: ${response.status}`);
        }

        statusDiv.textContent = 'Message submitted successfully!';
        form.reset();

      } catch (error: any) {
        console.error('Submission error:', error);
        statusDiv.textContent = `Error: ${error.message || 'Could not submit message.'}`;

      } finally {
        submitButton.disabled = false;
        submitButton.textContent = 'Submit';
      }
    });
  } else {
    console.error('Could not find all required form elements for guestbook submission script.');
  }
</script>
```
---

`src/layout/Layout.astro`:
```
---
interface Props {
  title: string;
}

const description = "Astro and Supabase demo app";
const { title } = Astro.props;
const ogImageURL = new URL("hero.png", Astro.site).href;
const canonicalURL = new URL(Astro.url).href;
---

<html lang="en">
  <head>
    <title>{title}</title>
    <meta charset="utf-8" />
    <link rel="icon" type="image/svg+xml" href="/favicon.svg" />
    <meta name="viewport" content="width=device-width" />
    <meta name="generator" content={Astro.generator} />
    <meta name="description" content={description} />
    <meta property="twitter:image" content={ogImageURL} />
    <meta property="twitter:card" content="summary_large_image" />
    <meta property="twitter:title" content={title} />
    <meta property="twitter:description" content={description} />
    <meta property="og:image" content={ogImageURL} />
    <meta property="og:title" content={title} />
    <meta property="og:description" content={description} />
    <meta property="og:url" content={canonicalURL} />
  </head>
  <body>
    <nav>
      <div>
        <a href="/">Astro</a>
        <div>
          <ul>
            <li>
              <a href="/dashboard">Dashboard</a>
            </li>
            <li>
              <a href="/signin">Sign in</a>
            </li>
          </ul>
        </div>
      </div>
    </nav>
    <slot />
  </body>
</html>
```
---

`src/lib/supabase.ts`:
```
// src/lib/supabase.ts
import { createClient } from "@supabase/supabase-js";

const supabaseUrl = import.meta.env.PUBLIC_SUPABASE_URL;
const supabaseAnonKey = import.meta.env.PUBLIC_SUPABASE_ANON_KEY;

if (!supabaseUrl || !supabaseAnonKey) {
  throw new Error("Supabase URL or Anon Key is missing.");
}

export const supabase = createClient(
  supabaseUrl,
  supabaseAnonKey,
  {
    auth: {
      flowType: "pkce",
      autoRefreshToken: true,
      detectSessionInUrl: false,
      persistSession: true,
    },
  },
);
```
---

`src/middleware/index.ts`:
```
// src/middleware/index.ts
import { defineMiddleware } from "astro:middleware";
import { supabase } from "../lib/supabase";
// No need to import micromatch anymore

// Define routes clearly
// For simple paths, direct string comparison after normalization is often easiest
const protectedPaths = ["/dashboard"];
const redirectPaths = ["/signin", "/register"];
const protectedAPIPaths = ["/api/guestbook"];

// Helper function to check paths, handling optional trailing slash
function matchesPath(pathname: string, pathsToCheck: string[]): boolean {
  // Normalize pathname by removing trailing slash (if present)
  const normalizedPathname = pathname.endsWith('/') && pathname.length > 1
    ? pathname.slice(0, -1)
    : pathname;
  return pathsToCheck.includes(normalizedPathname);
}

// --- OR using URLPattern (slightly more overhead for this simple case, but good for complex patterns) ---
/*
const protectedPatterns = [
  new URLPattern({ pathname: '/dashboard' }),
  new URLPattern({ pathname: '/dashboard/' }) // Handle trailing slash explicitly
];
const redirectPatterns = [
  new URLPattern({ pathname: '/signin' }),
  new URLPattern({ pathname: '/signin/' }),
  new URLPattern({ pathname: '/register' }),
  new URLPattern({ pathname: '/register/' })
];
const protectedAPIPatterns = [
    new URLPattern({ pathname: '/api/guestbook' }),
    new URLPattern({ pathname: '/api/guestbook/' })
];

function matchesPattern(url: URL, patterns: URLPattern[]): boolean {
    return patterns.some(pattern => pattern.test(url));
}
*/
// --- End of URLPattern example ---


export const onRequest = defineMiddleware(
  async ({ locals, url, cookies, redirect }, next) => {

    // Choose one method: matchesPath (simpler) or matchesPattern (URLPattern)
    const isProtectedRoute = matchesPath(url.pathname, protectedPaths);
    // const isProtectedRoute = matchesPattern(url, protectedPatterns); // URLPattern alternative

    if (isProtectedRoute) {
      const accessToken = cookies.get("sb-access-token");
      const refreshToken = cookies.get("sb-refresh-token");

      if (!accessToken || !refreshToken) {
        return redirect("/signin");
      }

      const { data, error } = await supabase.auth.setSession({
        refresh_token: refreshToken.value,
        access_token: accessToken.value,
      });

      if (error) {
        cookies.delete("sb-access-token", { path: "/" });
        cookies.delete("sb-refresh-token", { path: "/" });
        return redirect("/signin");
      }

      locals.email = data.user?.email!;
      cookies.set("sb-access-token", data?.session?.access_token!, {
        sameSite: "strict",
        path: "/",
        secure: true,
        httpOnly: true
      });
      cookies.set("sb-refresh-token", data?.session?.refresh_token!, {
        sameSite: "strict",
        path: "/",
        secure: true,
        httpOnly: true,
      });
    }

    const isRedirectRoute = matchesPath(url.pathname, redirectPaths);
    // const isRedirectRoute = matchesPattern(url, redirectPatterns); // URLPattern alternative

    if (isRedirectRoute) {
      const accessToken = cookies.get("sb-access-token");
      const refreshToken = cookies.get("sb-refresh-token");

      if (accessToken && refreshToken) {
        // Maybe quickly verify tokens here before redirecting? Optional.
        return redirect("/dashboard");
      }
    }

    const isProtectedAPIRoute = matchesPath(url.pathname, protectedAPIPaths);
    // const isProtectedAPIRoute = matchesPattern(url, protectedAPIPatterns); // URLPattern alternative

    if (isProtectedAPIRoute) {
      const accessToken = cookies.get("sb-access-token");
      const refreshToken = cookies.get("sb-refresh-token");

      if (!accessToken || !refreshToken) {
        return new Response(JSON.stringify({ error: "Unauthorized" }), { status: 401 });
      }

      const { error } = await supabase.auth.getUser(accessToken.value);

      if (error) {
         if (refreshToken) {
            const { error: refreshError } = await supabase.auth.setSession({
                 refresh_token: refreshToken.value,
                 access_token: accessToken.value,
            });
             if (refreshError) {
                 cookies.delete("sb-access-token", { path: "/" });
                 cookies.delete("sb-refresh-token", { path: "/" });
                 return new Response(JSON.stringify({ error: "Unauthorized - Session Refresh Failed" }), { status: 401 });
             }
             // Proceed carefully, maybe re-check or let the request handler proceed.
             // For simplicity here, we'll just proceed assuming setSession handles validity.
         } else {
            return new Response(JSON.stringify({ error: "Unauthorized - Invalid Token" }), { status: 401 });
         }
      }
    }
    return next();
  },
);
```
---

`src/pages/dashboard.astro`:
```
---
// src/pages/dashboard.astro
import Layout from "../layout/Layout.astro";
import { supabase } from "../lib/supabase";
import Reviews from "../components/Reviews.astro";
import type { GuestbookEntry } from "../types/types";

const { email } = Astro.locals;

let reviews: GuestbookEntry[] = [];
let fetchError: string | null = null;

try {
  const { data, error } = await supabase
    .from("guestbook")
    .select("name, message")
    .order("created_at", { ascending: false });

  if (error) {
    throw error;
  }
  reviews = data as GuestbookEntry[];

} catch (e: any) {
   fetchError = `Failed to load reviews: ${e.message}`;
   console.error("Error fetching reviews:", e);
}
---

<Layout title="Dashboard">
  <section>
    <p>
      Logged in as: <strong>{email}</strong>
    </p>
    <p>
      This is a protected page. You can only see this if you are logged in.
    </p>
    <a
      href="/api/auth/signout"
      >Sign out</a
    >

    {fetchError && <p>{fetchError}</p>}

    <Reviews reviews={reviews} />
  </section>
</Layout>
```
---

`src/pages/index.astro`:
```
---
import Layout from "../layout/Layout.astro";
export const prerender = true;
const title = "Supabase and Astro Demo";
---

<Layout title={title}>
  <main>
    <h1>{title}</h1>
    <ul>
      <li
      >
      </li>
       &plus;
      <li
      >
      </li>
    </ul>
    <p>This page was pre-rendered at build time</p>
  </main>
</Layout>

```
---

`src/pages/signin.astro`:
```
---
// src/pages/signin.astro
import Layout from "../layout/Layout.astro";
const title = "Sign In";
---

<Layout title={title}>
  <main>
    <section>
      <h1>{title}</h1>
      <p>
        Use Google to sign in to your account.
      </p>
      <form
        action="/api/auth/signin"
        method="post"
      >
        <button
          value="google"
          name="provider"
          type="submit"
        >
           Sign in with Google
        </button>
      </form>
    </section>
  </main>
</Layout>
```
---

`src/pages/api/guestbook.ts`:
```
import type { APIRoute } from "astro";
import { supabase } from "../../lib/supabase";

export const GET: APIRoute = async () => {
  const { data, error } = await supabase
    .from("guestbook")
    .select("*")
    .order("created_at", { ascending: true });

  if (error) {
    return new Response(
      JSON.stringify({
        error: error.message,
      }),
      { status: 500 },
    );
  }
  
  return new Response(JSON.stringify(data));
};

export const POST: APIRoute = async ({ request }) => {
  const { name, message } = await request.json();
  const { data, error } = await supabase
    .from("guestbook")
    .insert({ name, message })
    .select();

  if (error) {
    return new Response(
      JSON.stringify({
        error: error.message,
      }),
      { status: 500 },
    );
  }

  return new Response(JSON.stringify(data));
};

```
---

`src/pages/api/auth/callback.ts`:
```
import type { APIRoute } from "astro";
import { supabase } from "../../../lib/supabase";

export const GET: APIRoute = async ({ url, cookies, redirect }) => {
  const authCode = url.searchParams.get("code");

  if (!authCode) {
    return new Response("No code provided", { status: 400 });
  }

  const { data, error } = await supabase.auth.exchangeCodeForSession(authCode);

  if (error) {
    return new Response(error.message, { status: 500 });
  }

  const { access_token, refresh_token } = data.session;

  cookies.set("sb-access-token", access_token, {
    path: "/",
    secure: true,
    httpOnly: true,
  });
  cookies.set("sb-refresh-token", refresh_token, {
    path: "/",
    secure: true,
    httpOnly: true,
  });
  return redirect("/dashboard");
};

```
---

`src/pages/api/auth/signin.ts`:
```
import type { APIRoute } from "astro";
import { supabase } from "../../../lib/supabase";
import type { Provider } from "@supabase/supabase-js";

const OAUTH_CALLBACK_PATH = "/api/auth/callback";

export const POST: APIRoute = async ({ request, cookies, redirect, url }) => {
  const formData = await request.formData();
  const provider = formData.get("provider")?.toString();

  const redirectUrl = `${url.origin}${OAUTH_CALLBACK_PATH}`;

  if (provider === "google") {
    const { data, error } = await supabase.auth.signInWithOAuth({
      provider: provider as Provider,
      options: {
        redirectTo: redirectUrl,
      },
    });

    if (error) {
      console.error("OAuth Error:", error.message);
      return new Response(error.message, { status: 500 });
    }

    return redirect(data.url);
  }
  return new Response("Invalid sign-in method", { status: 400 });
};
```
---

`src/pages/api/auth/signout.ts`:
```
import type { APIRoute } from "astro";

export const GET: APIRoute = async ({ cookies, redirect }) => {
  cookies.delete("sb-access-token", { path: "/" });
  cookies.delete("sb-refresh-token", { path: "/" });
  return redirect("/signin");
};

```
---

`src/types/types.ts`:
```
// src/types/types.ts
export interface GuestbookEntry {
    name: string;
    message: string;
  }
```
---
